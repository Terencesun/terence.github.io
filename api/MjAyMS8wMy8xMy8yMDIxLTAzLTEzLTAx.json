{"title":"【Go语言核心36讲】47. 基于HTTP协议的网络服务","date":"2021-03-13T06:05:14.000Z","date_formatted":{"ll":"Mar 13, 2021","L":"03/13/2021","MM-DD":"03-13"},"link":"2021/03/13/2021-03-13-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.565Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>http.Client相关源码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Client struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Transport字段表示</span><br><span class=\"line\">    &#x2F;&#x2F; 向网络服务发送http请求，并从网络服务接收http响应操作过程</span><br><span class=\"line\">    &#x2F;&#x2F; 简单来说就是transport实现的是单次http事务的所需要的的所有步骤</span><br><span class=\"line\">\tTransport RoundTripper</span><br><span class=\"line\">\tCheckRedirect func(req *Request, via []*Request) error</span><br><span class=\"line\">\tJar CookieJar</span><br><span class=\"line\">\tTimeout time.Duration</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type RoundTripper interface &#123;</span><br><span class=\"line\">\tRoundTrip(*Request) (*Response, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 如果使用client的零值，就会使用默认的transport</span><br><span class=\"line\">var DefaultTransport RoundTripper &#x3D; &amp;Transport&#123;</span><br><span class=\"line\">\tProxy: ProxyFromEnvironment,</span><br><span class=\"line\">\tDialContext: (&amp;net.Dialer&#123;</span><br><span class=\"line\">\t\tTimeout:   30 * time.Second,</span><br><span class=\"line\">\t\tKeepAlive: 30 * time.Second,</span><br><span class=\"line\">\t\tDualStack: true,</span><br><span class=\"line\">\t&#125;).DialContext,</span><br><span class=\"line\">\tForceAttemptHTTP2:     true,</span><br><span class=\"line\">\t&#x2F;&#x2F; 在默认情况下，空闲连接的总数最大为100，而针对每个网络服务的最大空闲连接数为2</span><br><span class=\"line\">\tMaxIdleConns:          100,</span><br><span class=\"line\">\tIdleConnTimeout:       90 * time.Second,</span><br><span class=\"line\">\tTLSHandshakeTimeout:   10 * time.Second,</span><br><span class=\"line\">\tExpectContinueTimeout: 1 * time.Second,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Transport结构体</span><br><span class=\"line\">type Transport struct &#123;</span><br><span class=\"line\">\tidleMu       sync.Mutex</span><br><span class=\"line\">\tcloseIdle    bool                                &#x2F;&#x2F; user has requested to close all idle conns</span><br><span class=\"line\">\tidleConn     map[connectMethodKey][]*persistConn &#x2F;&#x2F; most recently used at end</span><br><span class=\"line\">\tidleConnWait map[connectMethodKey]wantConnQueue  &#x2F;&#x2F; waiting getConns</span><br><span class=\"line\">\tidleLRU      connLRU</span><br><span class=\"line\">\treqMu       sync.Mutex</span><br><span class=\"line\">\treqCanceler map[cancelKey]func(error)</span><br><span class=\"line\">\taltMu    sync.Mutex   &#x2F;&#x2F; guards changing altProto only</span><br><span class=\"line\">\taltProto atomic.Value &#x2F;&#x2F; of nil or map[string]RoundTripper, key is URI scheme</span><br><span class=\"line\">\tconnsPerHostMu   sync.Mutex</span><br><span class=\"line\">\tconnsPerHost     map[connectMethodKey]int</span><br><span class=\"line\">\tconnsPerHostWait map[connectMethodKey]wantConnQueue &#x2F;&#x2F; waiting getConns</span><br><span class=\"line\">\tProxy func(*Request) (*url.URL, error)</span><br><span class=\"line\">\tDialContext func(ctx context.Context, network, addr string) (net.Conn, error)</span><br><span class=\"line\">\tDial func(network, addr string) (net.Conn, error)</span><br><span class=\"line\">\tDialTLSContext func(ctx context.Context, network, addr string) (net.Conn, error)</span><br><span class=\"line\">\tDialTLS func(network, addr string) (net.Conn, error)</span><br><span class=\"line\">\tTLSClientConfig *tls.Config</span><br><span class=\"line\">\tTLSHandshakeTimeout time.Duration  &#x2F;&#x2F; TLS 是 Transport Layer Security 的缩写，可以被翻译为传输层安全，基于 TLS 协议的连接在被建立时的握手阶段的超时时间</span><br><span class=\"line\">\tDisableKeepAlives bool</span><br><span class=\"line\">\tDisableCompression bool</span><br><span class=\"line\">\tMaxIdleConns int  &#x2F;&#x2F; 对空闲连接的总数做出限定</span><br><span class=\"line\">\t&#x2F;&#x2F; MaxIdleConnsPerHost字段的缺省值，由http.DefaultMaxIdleConnsPerHost变量代表，值为2</span><br><span class=\"line\">\tMaxIdleConnsPerHost int  &#x2F;&#x2F; 该Transport值访问的每一个网络服务的最大空闲连接数</span><br><span class=\"line\">\t&#x2F;&#x2F; Zero means no limit.</span><br><span class=\"line\">\tMaxConnsPerHost int  &#x2F;&#x2F; 针对某一个Transport值访问的每一个网络服务的最大连接数，不论这些连接是否是空闲的，该字段没有相应的缺省值，它的零值表示不对此设限</span><br><span class=\"line\">\t&#x2F;&#x2F; Zero means no limit.</span><br><span class=\"line\">\tIdleConnTimeout time.Duration  &#x2F;&#x2F; 空闲的链接在多久之后就关闭</span><br><span class=\"line\">\tResponseHeaderTimeout time.Duration  &#x2F;&#x2F; 客户端把请求完全递交给操作系统到从操作系统就收到报文头的最大时长</span><br><span class=\"line\">\tExpectContinueTimeout time.Duration  &#x2F;&#x2F; 在客户端递交了请求报文头之后，等待接收第一个响应报文头的最长时间</span><br><span class=\"line\">\tTLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper</span><br><span class=\"line\">\tProxyConnectHeader Header</span><br><span class=\"line\">\t&#x2F;&#x2F; Zero means to use a default limit.</span><br><span class=\"line\">\tMaxResponseHeaderBytes int64</span><br><span class=\"line\">\t&#x2F;&#x2F; If zero, a default (currently 4KB) is used.</span><br><span class=\"line\">\tWriteBufferSize int</span><br><span class=\"line\">\t&#x2F;&#x2F; If zero, a default (currently 4KB) is used.</span><br><span class=\"line\">\tReadBufferSize int</span><br><span class=\"line\">\tnextProtoOnce      sync.Once</span><br><span class=\"line\">\th2transport        h2Transport </span><br><span class=\"line\">\ttlsNextProtoWasNil bool       </span><br><span class=\"line\">\tForceAttemptHTTP2 bool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>为什么会出现空闲的链接</li>\n</ol>\n<ul>\n<li>HTTP 协议有一个请求报文头叫做“Connection”。在 HTTP 协议的 1.1 版本中，这个报文头的值默认是“keep-alive”</li>\n<li>在这种情况下的网络连接都是持久连接，它们会在当前的 HTTP 事务完成后仍然保持着连通性，因此是可以被复用的</li>\n<li>既然连接可以被复用，那么就会有两种可能。一种可能是，针对于同一个网络服务，有新的 HTTP 请求被递交，该连接被再次使用。另一种可能是，不再有对该网络服务的 HTTP 请求，该连接被闲置</li>\n<li>后一种可能就产生了空闲的连接。另外，如果分配给某一个网络服务的连接过多的话，也可能会导致空闲连接的产生，因为每一个新递交的 HTTP 请求，都只会征用一个空闲的连接</li>\n<li>如果我们想彻底地杜绝空闲连接的产生，那么可以在初始化Transport值的时候把它的DisableKeepAlives字段的值设定为true。这时，HTTP 请求的“Connection”报文头的值就会被设置为“close”。这会告诉网络服务，这个网络连接不必保持，当前的 HTTP 事务完成后就可以断开它了</li>\n<li>每当一个 HTTP 请求被递交时，就都会产生一个新的网络连接。这样做会明显地加重网络服务以及客户端的负载，并会让每个 HTTP 事务都耗费更多的时间</li>\n<li>在net.Dialer类型中，也有一个看起来很相似的字段KeepAlive。不过，它与前面所说的 HTTP 持久连接并不是一个概念，KeepAlive是直接作用在底层的 socket 上的，它的背后是一种针对网络连接（更确切地说，是 TCP 连接）的存活探测机制。它的值用于表示每间隔多长时间发送一次探测包。当该值不大于0时，则表示不开启这种机制。DefaultTransport会把这个字段的值设定为30秒</li>\n<li>上面说的KeepAlive就是一个看下连接是不是活的，不是活的就从pool里面拿掉</li>\n</ul>\n<ol start=\"3\">\n<li>http.Server类型的ListenAndServe方法</li>\n</ol>\n<ul>\n<li>监听一个基于 TCP 协议的网络地址，并对接收到的 HTTP 请求进行处理</li>\n<li>这个方法会默认开启针对网络连接的存活探测机制，以保证连接是持久的</li>\n<li>该方法会一直执行，直到有严重的错误发生或者被外界关掉。当被外界关掉时，它会返回一个由http.ErrServerClosed变量代表的错误值</li>\n</ul>\n<ol start=\"4\">\n<li>ListenAndServe方法做了以下事情</li>\n</ol>\n<ul>\n<li>检查当前的http.Server类型的值（以下简称当前值）的Addr字段</li>\n<li>调用net.Listen函数在已确定的网络地址上启动基于 TCP 协议的监听</li>\n<li>检查net.Listen函数返回的错误值</li>\n<li>在for循环中，ListnAndServe会调用Accept，会返回两个结果，net.Conn类型的值和一个err</li>\n<li>如果err != nil，如果不是一个暂时性错误，那么for循环会被终止报错，如果是一个暂时性错误，循环会继续执行</li>\n<li>如果err = nil的话，那么net.Conn会包装成一个*http.conn类型的值，然后新开一个goroutine，处理这个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (srv *Server) ListenAndServe() error &#123;</span><br><span class=\"line\">\tif srv.shuttingDown() &#123;</span><br><span class=\"line\">\t\treturn ErrServerClosed</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taddr :&#x3D; srv.Addr</span><br><span class=\"line\">\tif addr &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class=\"line\">\t\taddr &#x3D; &quot;:http&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn srv.Serve(ln)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (srv *Server) Serve(l net.Listener) error &#123;</span><br><span class=\"line\">\tif fn :&#x3D; testHookServerServe; fn !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tfn(srv, l) &#x2F;&#x2F; call hook with unwrapped listener</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\torigListener :&#x3D; l</span><br><span class=\"line\">\tl &#x3D; &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class=\"line\">\tdefer l.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif err :&#x3D; srv.setupHTTP2_Serve(); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif !srv.trackListener(&amp;l, true) &#123;</span><br><span class=\"line\">\t\treturn ErrServerClosed</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer srv.trackListener(&amp;l, false)</span><br><span class=\"line\"></span><br><span class=\"line\">\tbaseCtx :&#x3D; context.Background()</span><br><span class=\"line\">\tif srv.BaseContext !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tbaseCtx &#x3D; srv.BaseContext(origListener)</span><br><span class=\"line\">\t\tif baseCtx &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tpanic(&quot;BaseContext returned a nil context&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar tempDelay time.Duration &#x2F;&#x2F; how long to sleep on accept failure</span><br><span class=\"line\"></span><br><span class=\"line\">\tctx :&#x3D; context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 在这里开启for循环，调用了Accept</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\trw, err :&#x3D; l.Accept()</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-srv.getDoneChan():</span><br><span class=\"line\">\t\t\t\treturn ErrServerClosed</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif ne, ok :&#x3D; err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class=\"line\">\t\t\t\tif tempDelay &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\t\ttempDelay &#x3D; 5 * time.Millisecond</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\ttempDelay *&#x3D; 2</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif max :&#x3D; 1 * time.Second; tempDelay &gt; max &#123;</span><br><span class=\"line\">\t\t\t\t\ttempDelay &#x3D; max</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsrv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, err, tempDelay)</span><br><span class=\"line\">\t\t\t\ttime.Sleep(tempDelay)</span><br><span class=\"line\">\t\t\t\tcontinue</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tconnCtx :&#x3D; ctx</span><br><span class=\"line\">\t\tif cc :&#x3D; srv.ConnContext; cc !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tconnCtx &#x3D; cc(connCtx, rw)</span><br><span class=\"line\">\t\t\tif connCtx &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tpanic(&quot;ConnContext returned nil&quot;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttempDelay &#x3D; 0</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 包装conn</span><br><span class=\"line\">\t\tc :&#x3D; srv.newConn(rw)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 设置conn状态</span><br><span class=\"line\">\t\t&#x2F;&#x2F; StateNew</span><br><span class=\"line\">\t\t&#x2F;&#x2F; StateHijacked</span><br><span class=\"line\">\t\t&#x2F;&#x2F; StateClosed</span><br><span class=\"line\">\t\tc.setState(c.rwc, StateNew) &#x2F;&#x2F; before Serve can return</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 创建了一个新的goroutine来处理conn</span><br><span class=\"line\">\t\tgo c.serve(connCtx)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis (1) 之编写 TCP 服务器","link":"2021/03/13/2021-03-13-02"},"next":{"title":"【Go语言核心36讲】46. 访问网络服务","link":"2021/03/12/2021-03-12-02"},"plink":"https://terence.segofun.com/2021/03/13/2021-03-13-01/","reading_time":"1940 words in 13 min"}