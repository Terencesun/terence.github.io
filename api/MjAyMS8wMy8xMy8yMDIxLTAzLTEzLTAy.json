{"title":"【转载】Go 项目实战：实现一个 Redis (1) 之编写 TCP 服务器","date":"2021-03-13T15:03:05.000Z","date_formatted":{"ll":"Mar 13, 2021","L":"03/13/2021","MM-DD":"03-13"},"link":"2021/03/13/2021-03-13-02","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.565Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443671&amp;idx=2&amp;sn=193ebda4599334be1e61b617e185deb7&amp;chksm=80bb0f25b7cc86337cb23c5c6f6fde6e7f837dfbaf13be86be0e046178d5e97c2662557123c5&amp;scene=21#wechat_redirect\" target=\"_blank\">mp.weixin.qq.com</a></p>\n</blockquote>\n<p>Golang 作为广泛用于服务端和云计算领域的编程语言，tcp socket 是其中至关重要的功能。无论是 WEB 服务器还是各类中间件都离不开 tcp socket 的支持。</p>\n<ul>\n<li>\n<p>Echo 服务器</p>\n</li>\n<li>\n<p>拆包与粘包</p>\n</li>\n<li>\n<p>优雅关闭</p>\n</li>\n</ul>\n<p>您可以在 Github:HDT3213/Godis[1] 项目中看到本文所述 TCP 服务器的完整代码及其应用。</p>\n<p>IO 模型是网络编程中最基础的话题。早期的 Tomcat/Apache 服务器使用 BlockingIO 模型，使用一个线程 listen 端口当建立新连接后将其交给另一个线程处理。因为每个连接都需要一个线程，因此内存占用及上下文切换带来的开销极大。</p>\n<p>此后的 Nginx/Netty/Tornado 使用 select/poll/epoll 等多路 IO 复用模型它使用一个线程监听多个连接，当任一连接收到数据后监听线程都会收到一个事件并处理它，从而实现在一个线程中交替处理多个连接的 IO 操作。因为多个连接 “复用” 了一个线程，所以需要的线程数少很多开销也小的多。有得必有失，由于需要在一个线程中处理多个连接，开发多路 IO 复用程序要难得多。</p>\n<p>因为 Golang 拥有内存占用和调度开销都很小的 goroutine, 因此我们可以让 BlockingIO 焕发第二春。得益于轻量级的 goroutine 我们可以为每个连接分配一个协程，在降低开发难度同时获得不错的性能。</p>\n<h2 id=\"echo-服务器\">Echo 服务器<a title=\"#echo-服务器\" href=\"#echo-服务器\"></a></h2>\n<p>作为开始，我们来实现一个简单的 Echo 服务器。它会接受客户端连接并将客户端发送的内容原样传回客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;net&quot;</span><br><span class=\"line\">    &quot;io&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;bufio&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func ListenAndServe(address string) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 绑定监听地址</span><br><span class=\"line\">    listener, err :&#x3D; net.Listen(&quot;tcp&quot;, address)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        log.Fatal(fmt.Sprintf(&quot;listen err: %v&quot;, err))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defer listener.Close()</span><br><span class=\"line\">    log.Println(fmt.Sprintf(&quot;bind: %s, start listening...&quot;, address))</span><br><span class=\"line\"></span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Accept 会一直阻塞直到有新的连接建立或者listen中断才会返回</span><br><span class=\"line\">        conn, err :&#x3D; listener.Accept()</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 通常是由于listener被关闭无法继续监听导致的错误</span><br><span class=\"line\">            log.Fatal(fmt.Sprintf(&quot;accept err: %v&quot;, err))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 开启新的 goroutine 处理该连接</span><br><span class=\"line\">        go Handle(conn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Handle(conn net.Conn) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 使用 bufio 标准库提供的缓冲区功能</span><br><span class=\"line\">    reader :&#x3D; bufio.NewReader(conn)</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; ReadString 会一直阻塞直到遇到分隔符 &#39;\\n&#39;</span><br><span class=\"line\">        &#x2F;&#x2F; 遇到分隔符后会返回上次遇到分隔符或连接建立后收到的所有数据, 包括分隔符本身</span><br><span class=\"line\">        &#x2F;&#x2F; 若在遇到分隔符之前遇到异常, ReadString 会返回已收到的数据和错误信息</span><br><span class=\"line\">        msg, err :&#x3D; reader.ReadString(&#39;\\n&#39;)</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 通常遇到的错误是连接中断或被关闭，用io.EOF表示</span><br><span class=\"line\">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class=\"line\">                log.Println(&quot;connection close&quot;)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                log.Println(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b :&#x3D; []byte(msg)</span><br><span class=\"line\">        &#x2F;&#x2F; 将收到的信息发送给客户端</span><br><span class=\"line\">        conn.Write(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    ListenAndServe(&quot;:8000&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用 telnet 工具测试我们编写的 Echo 服务器:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ telnet 127.0.0.1 8000</span><br><span class=\"line\">Trying 127.0.0.1...</span><br><span class=\"line\">Connected to 127.0.0.1.</span><br><span class=\"line\">Escape character is &#39;^]&#39;.</span><br><span class=\"line\">&gt; a</span><br><span class=\"line\">a</span><br><span class=\"line\">&gt; b</span><br><span class=\"line\">b</span><br><span class=\"line\">Connection closed by foreign host.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"拆包与粘包问题\">拆包与粘包问题<a title=\"#拆包与粘包问题\" href=\"#拆包与粘包问题\"></a></h2>\n<blockquote>\n<p>某些朋友可能看到 “拆包与粘包” 后表示极度震惊，并再三强调: TCP 是个字节流协议不存在粘包问题。</p>\n</blockquote>\n<p>TCP 协议确实是面向字节流的协议，当我们开发 TCP 服务器 (其实是基于 TCP 协议的应用层服务器) 时有义务正确地从字节流中解析出应用层消息。</p>\n<p>大多数语言提供的 TCP 接口允许我们通过 read() 函数读取新收到的一段数据，当然这段数据并不一定对应一个 TCP 包。</p>\n<p>举例来说，在 Echo 服务器的示例中，我们定义用<code>\\n</code>表示消息结束。我们可能遇到下列几种情况:</p>\n<ol>\n<li>\n<p>收到两段数据: “abc”, “def\\n”, 应发出一条响应 “abcdef\\n”, 这是拆包的情况</p>\n</li>\n<li>\n<p>收到一段数据: “abc\\ndef\\n”, 应发出两条响应 “abc\\n”, “def\\n”, 这是粘包的情况</p>\n</li>\n</ol>\n<p>上层协议通常采用下列几种思路之一来定义消息，以保证完整地进行读取:</p>\n<ul>\n<li>\n<p>定长消息</p>\n</li>\n<li>\n<p>在消息尾部添加特殊分隔符，如示例中的 Echo 协议和 FTP 控制协议。bufio 标准库会缓存收到的数据直到遇到分隔符才会返回，它可以帮助我们正确地分割字节流。</p>\n</li>\n<li>\n<p>将消息分为 header 和 body, 并在 header 中提供 body 总长度，这种分包方式被称为 LTV(length，type，value) 包。这是应用最广泛的策略，如 HTTP 协议。当从 header 中获得 body 长度后, io.ReadFull 函数会读取指定长度字节流，从而解析应用层消息。</p>\n</li>\n</ul>\n<p>在没有具体应用层协议的情况下，我们很难详细地讨论拆包与粘包问题。在本系列的第二篇文章: 实现 Redis 协议解析器 [2] 中我们可以看到 Redis 序列化协议 (RESP) 对分隔符和 LTV 包的结合应用，以及两种分包方式的具体解析代码。</p>\n<h2 id=\"优雅关闭\">优雅关闭<a title=\"#优雅关闭\" href=\"#优雅关闭\"></a></h2>\n<p>在生产环境下需要保证 TCP 服务器关闭前完成必要的清理工作，包括将完成正在进行的数据传输，关闭 TCP 连接等。这种关闭模式称为优雅关闭，可以避免资源泄露以及客户端未收到完整数据造成异常。</p>\n<p>TCP 服务器的优雅关闭模式通常为: 先关闭 listener 阻止新连接进入，然后遍历所有连接逐个进行关闭。</p>\n<p>首先修改一下 TCP 服务器:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; handler 是应用层服务器的抽象</span><br><span class=\"line\">type Handler interface &#123;</span><br><span class=\"line\">    Handle(ctx context.Context, conn net.Conn)</span><br><span class=\"line\">    Close()error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func ListenAndServe(cfg *Config, handler tcp.Handler) &#123;</span><br><span class=\"line\">    listener, err :&#x3D; net.Listen(&quot;tcp&quot;, cfg.Address)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        logger.Fatal(fmt.Sprintf(&quot;listen err: %v&quot;, err))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 监听中断信号</span><br><span class=\"line\">    &#x2F;&#x2F; atomic.AtomicBool 是作者写的封装: https:&#x2F;&#x2F;github.com&#x2F;HDT3213&#x2F;godis&#x2F;blob&#x2F;master&#x2F;src&#x2F;lib&#x2F;sync&#x2F;atomic&#x2F;bool.go</span><br><span class=\"line\">    var closing atomic.AtomicBool</span><br><span class=\"line\">    sigCh :&#x3D; make(chan os.Signal, 1)</span><br><span class=\"line\">    signal.Notify(sigCh, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)</span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        sig :&#x3D; &lt;-sigCh</span><br><span class=\"line\">        switch sig &#123;</span><br><span class=\"line\">        case syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:</span><br><span class=\"line\">            &#x2F;&#x2F; 收到中断信号后开始关闭流程</span><br><span class=\"line\">            logger.Info(&quot;shuting down...&quot;)</span><br><span class=\"line\">            &#x2F;&#x2F; 设置标志位为关闭中, 使用原子操作保证线程可见性</span><br><span class=\"line\">            closing.Set(true)</span><br><span class=\"line\">            &#x2F;&#x2F; 先关闭 listener 阻止新连接进入</span><br><span class=\"line\">            &#x2F;&#x2F; listener 关闭后 listener.Accept() 会立即返回错误</span><br><span class=\"line\">            _ &#x3D; listener.Close()</span><br><span class=\"line\">            &#x2F;&#x2F; 逐个关闭已建立链接</span><br><span class=\"line\">            _ &#x3D; handler.Close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    logger.Info(fmt.Sprintf(&quot;bind: %s, start listening...&quot;, cfg.Address))</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 在出现未知错误或panic后保证正常关闭</span><br><span class=\"line\">        &#x2F;&#x2F; 这里存在一个问题是: 当应用正常关闭后会再次执行关闭操作</span><br><span class=\"line\">        _ &#x3D; listener.Close()</span><br><span class=\"line\">        _ &#x3D; handler.Close()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    ctx, _ :&#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\">    &#x2F;&#x2F; waitGroup 的计数是当前仍存在的连接数</span><br><span class=\"line\">    &#x2F;&#x2F; 进入关闭流程时，主协程应该等待所有连接都关闭后再退出</span><br><span class=\"line\">    var waitDone sync.WaitGroup</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        conn, err :&#x3D; listener.Accept()</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            if closing.Get() &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 收到关闭信号后进入此流程，此时listener已被监听系统信号的 goroutine 关闭</span><br><span class=\"line\">                logger.Info(&quot;waiting disconnect...&quot;)</span><br><span class=\"line\">                &#x2F;&#x2F; 主协程应等待应用层服务器完成工作并关闭链接</span><br><span class=\"line\">                waitDone.Wait()</span><br><span class=\"line\">                return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            logger.Error(fmt.Sprintf(&quot;accept err: %v&quot;, err))</span><br><span class=\"line\">            continue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 创建一个新协程处理链接</span><br><span class=\"line\">        logger.Info(&quot;accept link&quot;)</span><br><span class=\"line\">        go func() &#123;</span><br><span class=\"line\">            defer func() &#123;</span><br><span class=\"line\">                waitDone.Done()</span><br><span class=\"line\">            &#125;()</span><br><span class=\"line\">            waitDone.Add(1)</span><br><span class=\"line\">            handler.Handle(ctx, conn)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来修改应用层服务器:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 客户端连接的抽象</span><br><span class=\"line\">type Client struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; tcp 连接</span><br><span class=\"line\">    Conn net.Conn</span><br><span class=\"line\">    &#x2F;&#x2F; 当服务端开始发送数据时进入waiting, 阻止其它goroutine关闭连接</span><br><span class=\"line\">    &#x2F;&#x2F; wait.Wait是作者编写的带有最大等待时间的封装:</span><br><span class=\"line\">    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;HDT3213&#x2F;godis&#x2F;blob&#x2F;master&#x2F;src&#x2F;lib&#x2F;sync&#x2F;wait&#x2F;wait.go</span><br><span class=\"line\">    Waiting wait.Wait</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type EchoHandler struct &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 保存所有工作状态client的集合(把map当set用)</span><br><span class=\"line\">    &#x2F;&#x2F; 需使用并发安全的容器</span><br><span class=\"line\">    activeConn sync.Map</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 和 tcp server 中作用相同的关闭状态标识位</span><br><span class=\"line\">    closing atomic.AtomicBool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func MakeEchoHandler()(*EchoHandler) &#123;</span><br><span class=\"line\">    return &amp;EchoHandler&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 关闭客户端连接</span><br><span class=\"line\">func (c *Client)Close()error &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 等待数据发送完成或超时</span><br><span class=\"line\">    c.Waiting.WaitWithTimeout(10 * time.Second)</span><br><span class=\"line\">    c.Conn.Close()</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (h *EchoHandler)Handle(ctx context.Context, conn net.Conn) &#123;</span><br><span class=\"line\">    if h.closing.Get() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; closing handler refuse new connection</span><br><span class=\"line\">        conn.Close()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    client :&#x3D; &amp;Client &#123;</span><br><span class=\"line\">        Conn: conn,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h.activeConn.Store(client, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">    reader :&#x3D; bufio.NewReader(conn)</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        msg, err :&#x3D; reader.ReadString(&#39;\\n&#39;)</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class=\"line\">                logger.Info(&quot;connection close&quot;)</span><br><span class=\"line\">                h.activeConn.Delete(conn)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                logger.Warn(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 发送数据前先置为waiting状态</span><br><span class=\"line\">        client.Waiting.Add(1)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 模拟关闭时未完成发送的情况</span><br><span class=\"line\">        &#x2F;&#x2F;logger.Info(&quot;sleeping&quot;)</span><br><span class=\"line\">        &#x2F;&#x2F;time.Sleep(10 * time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">        b :&#x3D; []byte(msg)</span><br><span class=\"line\">        conn.Write(b)</span><br><span class=\"line\">        &#x2F;&#x2F; 发送完毕, 结束waiting</span><br><span class=\"line\">        client.Waiting.Done()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (h *EchoHandler)Close()error &#123;</span><br><span class=\"line\">    logger.Info(&quot;handler shuting down...&quot;)</span><br><span class=\"line\">    h.closing.Set(true)</span><br><span class=\"line\">    &#x2F;&#x2F; TODO: concurrent wait</span><br><span class=\"line\">    h.activeConn.Range(func(key interface&#123;&#125;, val interface&#123;&#125;)bool &#123;</span><br><span class=\"line\">        client :&#x3D; key.(*Client)</span><br><span class=\"line\">        client.Close()</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作者：finley</p>\n<p>出处：<a href=\"https://www.cnblogs.com/Finley/p/11070669.html\" target=\"_blank\">https://www.cnblogs.com/Finley/p/11070669.html</a></p>\n<p>版权：本作品采用「署名 - 非商业性使用 - 相同方式共享 4.0 国际 [3]」许可协议进行许可。</p>\n</blockquote>\n<h3 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h3>\n<p>[1] Github:HDT3213/Godis: _<a href=\"https://github.com/HDT3213/godis/tree/master/src/tcp_\" target=\"_blank\">https://github.com/HDT3213/godis/tree/master/src/tcp_</a></p>\n<p>[2] 实现 Redis 协议解析器: _<a href=\"https://www.cnblogs.com/Finley/p/11923168.html_\" target=\"_blank\">https://www.cnblogs.com/Finley/p/11923168.html_</a></p>\n<p><strong>推荐阅读</strong></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443629&amp;idx=2&amp;sn=9f906c5103c613dc134ccf37522ccf50&amp;chksm=80bb0f5fb7cc86497e6b30601f2cae708c60ed7a7a47d8020d0a605f6e16a7769b789073cb1d&amp;scene=21#wechat_redirect\" target=\"_blank\">实战：150 行 Go 实现高性能 socks5 代理</a></strong></p>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis(2) 之实现 Redis 协议解析器","link":"2021/03/13/2021-03-13-03"},"next":{"title":"【Go语言核心36讲】47. 基于HTTP协议的网络服务","link":"2021/03/13/2021-03-13-01"},"plink":"https://terence.segofun.com/2021/03/13/2021-03-13-02/","toc":[{"id":"echo-服务器","title":"Echo 服务器","index":"1"},{"id":"拆包与粘包问题","title":"拆包与粘包问题","index":"2"},{"id":"优雅关闭","title":"优雅关闭","index":"3","children":[{"id":"参考资料","title":"参考资料","index":"3.1"}]}],"reading_time":"2492 words in 17 min"}