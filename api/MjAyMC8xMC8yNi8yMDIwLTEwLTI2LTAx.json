{"title":"【etcd】etcd入门学习","date":"2020-10-26T12:44:42.000Z","date_formatted":{"ll":"Oct 26, 2020","L":"10/26/2020","MM-DD":"10-26"},"link":"2020/10/26/2020-10-26-01","comments":true,"tags":["demo","ectd","golang","language"],"updated":"2020-10-26T12:47:50.388Z","content":"<h3 id=\"etcd\">etcd<a title=\"#etcd\" href=\"#etcd\"></a></h3>\n<h4 id=\"1.-etcd概念\">1. etcd概念<a title=\"#1.-etcd概念\" href=\"#1.-etcd概念\"></a></h4>\n<ol>\n<li>\n<p>etcd 是一个高可用强一致性的键值仓库在很多分布式系统架构中得到了广泛的应用，其最经典的使用场景就是服务发现</p>\n</li>\n<li>\n<p>etcd特点：</p>\n</li>\n</ol>\n<ul>\n<li>简单：易于部署，易使用，基于Http和json的api</li>\n<li>安全：可选SSL客户认证机制</li>\n<li>快速：每个实例每秒支持1000写操作</li>\n<li>可信：使用一致性Raft算法实现分布式</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>etcd 的场景默认处理的数据都是系统中的控制数据</p>\n</li>\n<li>\n<p>etcd中应该尽量只存储系统中服务的配置信息，对于应用数据只推荐把数据量很小，但是更新和访问频次都很高的数据存储在etcd中</p>\n</li>\n<li>\n<p>解决服务发现的问题，三个要素</p>\n</li>\n</ol>\n<ul>\n<li>一个强一致性、高可用的服务存储目录</li>\n<li>一种注册服务和监控服务健康状态的机制：用户可以在 etcd 中注册服务，并且对注册的服务设置 key TTL，定时保持服务的心跳以达到监控健康状态的效果</li>\n<li>一种查找和连接服务的机制：通过在 etcd 指定的主题（由服务名称构成的服务目录）下注册的服务也能在对应的主题下查找到</li>\n</ul>\n<ol start=\"6\">\n<li>etcd架构</li>\n</ol>\n<p><img src=\"/images/2020-10-26-01/etcd.jpg\" alt=\"image\" class=\"φcx\"></p>\n<ul>\n<li>HTTP Server：用于处理用户发送的 API 请求以及其它 etcd 节点的同步与心跳信息请求</li>\n<li>Store：用于处理 etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 etcd 对用户提供的大多数 API 功能的具体实现</li>\n<li>Raft：Raft 强一致性算法的具体实现，是 etcd 的核心</li>\n<li>WAL：Write Ahead Log（预写式日志），是 etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容</li>\n</ul>\n<ol start=\"7\">\n<li>\n<p>用户可以对etcd集群中的所有节点进行读写，读取非常简单因为每个节点保存的数据是强一致的</p>\n</li>\n<li>\n<p>对于写入来说，etcd集群中的节点会选举出Leader节点，如果写入请求来自Leader节点即可直接写入然后Leader节点会把写入分发给所有Follower，如果写入请求来自其他Follower节点那么写入请求会给转发给Leader节点，由Leader节点写入之后再分发给集群上的所有其他节点</p>\n</li>\n<li>\n<p>Raft算法使用随机Timer来初始化Leader选举流程。</p>\n</li>\n</ol>\n<p>比如一开始我们启动了三个节点，每个节点都开始运行Timer，每个Timer的持续时间都是随机的，然后如果第一个节点率先完成Timer，它就会向其他节点发送成为leader的请求，其他节点接收到请求后会以投票回应然后第一个节点被选举为Leader</p>\n<ol start=\"10\">\n<li>\n<p>初次成为leader的节点，会以固定时间间隔向其他节点发送通知，确保自己仍是leader，有些情况下，当follower们收不到leader的通知后，比如leader通信断了，其他节点会重复之前选举过程选出新的leader</p>\n</li>\n<li>\n<p>如何判断写入是否成功？</p>\n</li>\n</ol>\n<ul>\n<li>etcd认为写入请求被Leader节点处理并分发给了多数节点后，就是一个成功的写入</li>\n<li>如何界定多数节点呢，假设总节点数是N，那么多数节点的数量Quorum=(N/2) + 1</li>\n</ul>\n<ol start=\"12\">\n<li>如何确定etcd集群应该有多少个节点？</li>\n</ol>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>instances</th>\n<th>quorom</th>\n<th>failt tolerance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table></div></div><ul>\n<li>表格总，总实例数，多数节点数，和容错节点数量</li>\n<li>总实例数=多数节点数+容错节点数</li>\n<li>在集群中推荐的最少节点数量是3个，因为1和2个节点的容错节点数都是0，一旦有一个节点宕掉整个集群就不能正常工作了</li>\n<li>6个节点的集群它的容错能力并没有比5个节点的好，他们的容错节点数一样，一旦容错节点超过2后，由于Quorum节点数小于4整个集群也变为不可用的状态了</li>\n<li>在决定集群中的节点数时，奇数要优于偶数</li>\n</ul>\n<ol start=\"13\">\n<li>资料</li>\n</ol>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000020742981\" target=\"_blank\">看图轻松了解etcd</a></li>\n</ul>\n<h3 id=\"2.etcd基础操作\">2.etcd基础操作<a title=\"#2.etcd基础操作\" href=\"#2.etcd基础操作\"></a></h3>\n<ol>\n<li>\n<p>安装，<a href=\"https://github.com/etcd-io/etcd/releases\">https://github.com/etcd-io/etcd/releases</a></p>\n</li>\n<li>\n<p>etcd命令启动etcd，注意下面的输出日志，里面有两行</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\">2019-10-22 13:15:32.244300 I | embed: listening for peers on http:&#x2F;&#x2F;localhost:2380</span><br><span class=\"line\">2019-10-22 13:15:32.244466 I | embed: listening for client requests on localhost:2379</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2380是etcd服务中成员间通信端口，peer是对同一个etcd集群中另外一个member的称呼</li>\n<li>2379是etcd提供给外部客户端通信的端口</li>\n</ul>\n<ol start=\"3\">\n<li>启动配置</li>\n</ol>\n<ul>\n<li>-name 节点名称，默认是UUID</li>\n<li>-data-dir 保存日志和快照的目录，默认为当前工作目录</li>\n<li>-addr 公布的ip地址和端口。 默认为127.0.0.1:2379</li>\n<li>-bind-addr 用于客户端连接的监听地址，默认为-addr配置</li>\n<li>-peers 集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381</li>\n<li>-peer-addr 集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.</li>\n<li>-peer-bind-addr 集群服务通讯的监听地址，默认为-peer-addr配置</li>\n<li>上述配置也可以设置配置文件，默认为/etc/etcd/etcd.conf</li>\n</ul>\n<ol start=\"4\">\n<li>使用etcdctl进行操作</li>\n</ol>\n<ul>\n<li>etcdctl是官方给的简介客户端，可以用来学习</li>\n<li>put -&gt; 写入键值对</li>\n<li>get -&gt; 获取键值对</li>\n<li>update -&gt; 更新键值对，如果键不存在，会报错</li>\n<li>rm -&gt; 删除键值对</li>\n<li>member -&gt; 集群成员的操作，list/add/remove，列出/添加/删除etcd实例到etcd集群中</li>\n</ul>\n<ol start=\"5\">\n<li>资料</li>\n</ol>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000020787391\" target=\"_blank\">etcd常用操作介绍</a></li>\n</ul>\n<h3 id=\"3.-golang基本使用\">3. golang基本使用<a title=\"#3.-golang基本使用\" href=\"#3.-golang基本使用\"></a></h3>\n<p>用程序访问 etcd 首先要创建 client，它需要传入一个 Config 配置，这里传了 2 个选项：</p>\n<ul>\n<li>Endpoints：etcd 的多个节点服务地址。</li>\n<li>DialTimeout：创建 client 的首次连接超时时间，这里传了 5 秒，如果 5 秒都没有连接成功就会返回 err；一旦 client 创建成功，我们就不用再关心后续底层连接的状态了，client 内部会重连。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cli, err :&#x3D; clientv3.New(clientv3.Config&#123;</span><br><span class=\"line\">   Endpoints:   []string&#123;&quot;localhost:2379&quot;&#125;,</span><br><span class=\"line\">   &#x2F;&#x2F; Endpoints: []string&#123;&quot;localhost:2379&quot;, &quot;localhost:22379&quot;, &quot;localhost:32379&quot;&#125;</span><br><span class=\"line\">   DialTimeout: 5 * time.Second,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>返回的<code>client</code>，它的类型具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Client struct &#123;</span><br><span class=\"line\">    Cluster</span><br><span class=\"line\">    KV</span><br><span class=\"line\">    Lease</span><br><span class=\"line\">    Watcher</span><br><span class=\"line\">    Auth</span><br><span class=\"line\">    Maintenance</span><br><span class=\"line\">    &#x2F;&#x2F; Username is a user name for authentication.</span><br><span class=\"line\">    Username string</span><br><span class=\"line\">    &#x2F;&#x2F; Password is a password for authentication.</span><br><span class=\"line\">    Password string</span><br><span class=\"line\">    &#x2F;&#x2F; contains filtered or unexported fields</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类型中的成员是 etcd 客户端几何核心功能模块的具体实现，它们分别用于：</p>\n<ul>\n<li>Cluster：向集群里增加 etcd 服务端节点之类，属于管理员操作。</li>\n<li>KV：我们主要使用的功能，即 K-V 键值库的操作。</li>\n<li>Lease：租约相关操作，比如申请一个 TTL=10 秒的租约（应用给 key 可以实现键值的自动过期）。</li>\n<li>Watcher：观察订阅，从而监听最新的数据变化。</li>\n<li>Auth：管理 etcd 的用户和权限，属于管理员操作。</li>\n<li>Maintenance：维护 etcd，比如主动迁移 etcd 的 leader 节点，属于管理员操作。</li>\n</ul>\n<p>我们需要使用什么功能，就去 client 里获取对应的成员即可。</p>\n<p>Client.KV是一个<code>interface</code>，提供了关于 K-V 操作的所有方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type KV interface &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Put(ctx context.Context, key, val string, opts ...OpOption) (*PutResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    Get(ctx context.Context, key string, opts ...OpOption) (*GetResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Delete deletes a key, or optionally using WithRange(end), [key, end).</span><br><span class=\"line\">    Delete(ctx context.Context, key string, opts ...OpOption) (*DeleteResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Compact compacts etcd KV history before the given rev.</span><br><span class=\"line\">    Compact(ctx context.Context, rev int64, opts ...CompactOption) (*CompactResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    Do(ctx context.Context, op Op) (OpResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Txn creates a transaction.</span><br><span class=\"line\">    Txn(ctx context.Context) Txn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过方法<code>clientv3.NewKV()</code>来获得 KV 接口的实现（实现中内置了错误重试机制）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kv :&#x3D; clientv3.NewKV(cli)</span><br></pre></td></tr></table></figure>\n<p>接下来，我们将通过<code>kv</code>操作 etcd 中的数据。</p>\n<h3 id=\"put\">Put<a title=\"#put\" href=\"#put\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">putResp, err :&#x3D; kv.Put(context.TODO(),&quot;&#x2F;test&#x2F;key1&quot;, &quot;Hello etcd!&quot;)</span><br></pre></td></tr></table></figure>\n<p>第一个参数是<code>goroutine</code>的上下文<code>Context</code>。后面两个参数分别是 key 和 value，对于 etcd 来说，key=/test/key1 只是一个字符串而已，但是对我们而言却可以模拟出目录层级关系。</p>\n<p>Put 函数的声明如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Put puts a key-value pair into etcd.</span><br><span class=\"line\">&#x2F;&#x2F; Note that key,value can be plain bytes array and string is</span><br><span class=\"line\">&#x2F;&#x2F; an immutable representation of that bytes array.</span><br><span class=\"line\">&#x2F;&#x2F; To get a string of bytes, do string([]byte&#123;0x10, 0x20&#125;).</span><br><span class=\"line\">Put(ctx context.Context, key, val string, opts ...OpOption) (*PutResponse, error)</span><br></pre></td></tr></table></figure>\n<p>除了上面例子中的三个的参数，还支持一个变长参数，可以传递一些控制项来影响 Put 的行为，例如可以携带一个 lease ID 来支持 key 过期。</p>\n<p>Put 操作返回的是 PutResponse，不同的 KV 操作对应不同的 response 结构，所有 KV 操作返回的 response 结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type (</span><br><span class=\"line\">   CompactResponse pb.CompactionResponse</span><br><span class=\"line\">   PutResponse     pb.PutResponse</span><br><span class=\"line\">   GetResponse     pb.RangeResponse</span><br><span class=\"line\">   DeleteResponse  pb.DeleteRangeResponse</span><br><span class=\"line\">   TxnResponse     pb.TxnResponse</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>程序代码里导入<code>clientv3</code>后在 GoLand 中可以很快定位到<code>PutResponse</code>的定义文件中，PutResponse 只是 pb.PutResponse 的类型别名，通过 Goland 跳转过去后可以看到 PutResponse 的详细定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type PutResponse struct &#123;</span><br><span class=\"line\">   Header *ResponseHeader &#96;protobuf:&quot;bytes,1,opt,&#96;</span><br><span class=\"line\">   &#x2F;&#x2F; if prev_kv is set in the request, the previous key-value pair will be returned.</span><br><span class=\"line\">   PrevKv *mvccpb.KeyValue &#96;protobuf:&quot;bytes,2,opt,&#96;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Header 里保存的主要是本次更新的 revision 信息，而 PrevKv 可以返回 Put 覆盖之前的 value 是什么（目前是 nil，后面会说原因），把返回的<code>PutResponse</code>打印出来看一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(&quot;PutResponse: %v, err: %v&quot;, putResp, err)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; output</span><br><span class=\"line\">&#x2F;&#x2F; PutResponse: &amp;&#123;cluster_id:14841639068965178418 member_id:10276657743932975437 revision:3 raft_term:7  &lt;nil&gt;&#125;, err: &lt;nil&gt;%</span><br></pre></td></tr></table></figure>\n<p>我们需要判断 err 来确定操作是否成功。</p>\n<p>我们再 Put 其他 2 个 key，用于后续演示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kv.Put(context.TODO(),&quot;&#x2F;test&#x2F;key2&quot;, &quot;Hello World!&quot;)</span><br><span class=\"line\">&#x2F;&#x2F; 再写一个同前缀的干扰项</span><br><span class=\"line\">kv.Put(context.TODO(), &quot;&#x2F;testspam&quot;, &quot;spam&quot;)</span><br></pre></td></tr></table></figure>\n<p>现在 /test 目录下有两个键: key1 和 key2， 而 /testspam 并不归属于 /test 目录</p>\n<h3 id=\"get\">Get<a title=\"#get\" href=\"#get\"></a></h3>\n<p>使用 KV 的<code>Get</code>方法来读取给定键的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getResp, err :&#x3D; kv.Get(context.TODO(), &quot;&#x2F;test&#x2F;key1&quot;)</span><br></pre></td></tr></table></figure>\n<p>其函数声明如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Get retrieves keys.</span><br><span class=\"line\">&#x2F;&#x2F; By default, Get will return the value for &quot;key&quot;, if any.</span><br><span class=\"line\">&#x2F;&#x2F; When passed WithRange(end), Get will return the keys in the range [key, end).</span><br><span class=\"line\">&#x2F;&#x2F; When passed WithFromKey(), Get returns keys greater than or equal to key.</span><br><span class=\"line\">&#x2F;&#x2F; When passed WithRev(rev) with rev &gt; 0, Get retrieves keys at the given revision;</span><br><span class=\"line\">&#x2F;&#x2F; if the required revision is compacted, the request will fail with ErrCompacted .</span><br><span class=\"line\">&#x2F;&#x2F; When passed WithLimit(limit), the number of returned keys is bounded by limit.</span><br><span class=\"line\">&#x2F;&#x2F; When passed WithSort(), the keys will be sorted.</span><br><span class=\"line\">Get(ctx context.Context, key string, opts ...OpOption) (*GetResponse, error)</span><br></pre></td></tr></table></figure>\n<p>和 Put 类似，函数注释里提示我们可以传递一些控制参数来影响 Get 的行为，比如：WithFromKey 表示读取从参数 key 开始递增的所有 key，而不是读取单个 key。</p>\n<p>在上面的例子中，我没有传递 opOption，所以就是获取 key=/test/key1 的最新版本数据。</p>\n<p>这里 err 并不能反馈出 key 是否存在（只能反馈出本次操作因为各种原因异常了），我们需要通过 GetResponse（实际上是 pb.RangeResponse）判断 key 是否存在：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type RangeResponse struct &#123;</span><br><span class=\"line\">    Header *ResponseHeader &#96;protobuf:&quot;bytes,1,opt,&#96;</span><br><span class=\"line\">    &#x2F;&#x2F; kvs is the list of key-value pairs matched by the range request.</span><br><span class=\"line\">    &#x2F;&#x2F; kvs is empty when count is requested.</span><br><span class=\"line\">    Kvs []*mvccpb.KeyValue &#96;protobuf:&quot;bytes,2,rep,&#96;</span><br><span class=\"line\">    &#x2F;&#x2F; more indicates if there are more keys to return in the requested range.</span><br><span class=\"line\">    More bool &#96;protobuf:&quot;varint,3,opt,&#96;</span><br><span class=\"line\">    &#x2F;&#x2F; count is set to the number of keys within the range when requested.</span><br><span class=\"line\">    Count int64 &#96;protobuf:&quot;varint,4,opt,&#96;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Kvs 字段，保存了本次 Get 查询到的所有 k-v 对，因为上述例子只 Get 了一个单 key，所以只需要判断一下 len(Kvs) 是否等于 1 即可知道 key 是否存在。</p>\n<p><code>RangeResponse.More</code>和<code>Count</code>，当我们使用<code>withLimit()</code>等选项进行<code>Get</code>时会发挥作用，相当于翻页查询。</p>\n<p>接下来，我们通过给 Get 查询增加 WithPrefix 选项，获取 / test 目录下的所有子元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rangeResp, err :&#x3D; kv.Get(context.TODO(), &quot;&#x2F;test&#x2F;&quot;, clientv3.WithPrefix())</span><br></pre></td></tr></table></figure>\n<p><code>WithPrefix()</code>是指查找以<code>/test/</code>为前缀的所有 key，因此可以模拟出查找子目录的效果。</p>\n<p><code>etcd</code>是一个有序的 k-v 存储，因此 / test / 为前缀的 key 总是顺序排列在一起。</p>\n<p><code>withPrefix()</code>实际上会转化为范围查询，它根据前缀<code>/test/</code>生成了一个前闭后开的 key range：<code>[“/test/”, “/test0”)</code>，为什么呢？因为比<code>/</code>大的字符是<code>0</code>，所以以<code>/test0</code>作为范围的末尾，就可以扫描到所有以<code>/test/</code>为前缀的 key 了。</p>\n<p>在之前，我们 Put 了一个<code>/testspam</code>键值，因为不符合<code>/test/</code>前缀（注意末尾的 /），所以就不会被这次<code>Get</code>获取到。但是，如果查询的前缀是<code>/test</code>，那么<code>/testspam</code>就会被返回，使用时一定要特别注意。</p>\n<p>打印 rangeResp.Kvs 可以看到获得了两个键值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[key:&quot;&#x2F;test&#x2F;key1&quot; create_revision:2 mod_revision:13 version:6 value:&quot;Hello etcd!&quot;  key:&quot;&#x2F;test&#x2F;key2&quot; create_revision:5 mod_revision:14 version:4 value:&quot;Hello World!&quot; ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"lease\">Lease<a title=\"#lease\" href=\"#lease\"></a></h3>\n<p>etcd 客户端的 Lease 对象可以通过以下的代码获取到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lease :&#x3D; clientv3.NewLease(cli)</span><br></pre></td></tr></table></figure>\n<p>lease 对象是 Lease 接口的实现，Lease 接口的声明如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Lease interface &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Grant 创建一个新租约</span><br><span class=\"line\">    Grant(ctx context.Context, ttl int64) (*LeaseGrantResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Revoke 销毁给定租约ID的租约</span><br><span class=\"line\">    Revoke(ctx context.Context, id LeaseID) (*LeaseRevokeResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; TimeToLive retrieves the lease information of the given lease ID.</span><br><span class=\"line\">    TimeToLive(ctx context.Context, id LeaseID, opts ...LeaseOption) (*LeaseTimeToLiveResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Leases retrieves all leases.</span><br><span class=\"line\">    Leases(ctx context.Context) (*LeaseLeasesResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; KeepAlive keeps the given lease alive forever.</span><br><span class=\"line\">    KeepAlive(ctx context.Context, id LeaseID) (&lt;-chan *LeaseKeepAliveResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; KeepAliveOnce renews the lease once. In most of the cases, KeepAlive</span><br><span class=\"line\">    &#x2F;&#x2F; should be used instead of KeepAliveOnce.</span><br><span class=\"line\">    KeepAliveOnce(ctx context.Context, id LeaseID) (*LeaseKeepAliveResponse, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Close releases all resources Lease keeps for efficient communication</span><br><span class=\"line\">    &#x2F;&#x2F; with the etcd server.</span><br><span class=\"line\">    Close() error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Lease 提供了以下功能：</p>\n<ul>\n<li>Grant：分配一个租约。</li>\n<li>Revoke：释放一个租约。</li>\n<li>TimeToLive：获取剩余 TTL 时间。</li>\n<li>Leases：列举所有 etcd 中的租约。</li>\n<li>KeepAlive：自动定时的续约某个租约。</li>\n<li>KeepAliveOnce：为某个租约续约一次。</li>\n<li>Close：释放当前客户端建立的所有租约。</li>\n</ul>\n<p>要想实现 key 自动过期，首先得创建一个租约，下面的代码创建一个 TTL 为 10 秒的租约：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grantResp, err :&#x3D; lease.Grant(context.TODO(), 10)</span><br></pre></td></tr></table></figure>\n<p>返回的 grantResponse 的结构体声明如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; LeaseGrantResponse wraps the protobuf message LeaseGrantResponse.</span><br><span class=\"line\">type LeaseGrantResponse struct &#123;</span><br><span class=\"line\">    *pb.ResponseHeader</span><br><span class=\"line\">    ID    LeaseID</span><br><span class=\"line\">    TTL   int64</span><br><span class=\"line\">    Error string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在应用程序代码中主要使用到的是租约 ID。</p>\n<p>接下来我们用这个 Lease 往 etcd 中存储一个 10 秒过期的 key：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kv.Put(context.TODO(), &quot;&#x2F;test&#x2F;vanish&quot;, &quot;vanish in 10s&quot;, clientv3.WithLease(grantResp.ID))</span><br></pre></td></tr></table></figure>\n<p>这里特别需要注意，有一种情况是在 Put 之前 Lease 已经过期了，那么这个 Put 操作会返回 error，此时你需要重新分配 Lease。</p>\n<p>当我们实现服务注册时，需要主动给 Lease 进行续约，通常是以小于 TTL 的间隔循环调用 Lease 的 KeepAliveOnce() 方法对租约进行续期，一旦某个服务节点出错无法完成租约的续期，等 key 过期后客户端即无法在查询服务时获得对应节点的服务，这样就通过租约到期实现了服务的错误隔离。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keepResp, err :&#x3D; lease.KeepAliveOnce(context.TODO(), grantResp.ID)</span><br></pre></td></tr></table></figure>\n<p>或者使用<code>KeepAlive()</code>方法，其会返回<code>&lt;-chan *LeaseKeepAliveResponse</code>只读通道，每次自动续租成功后会向通道中发送信号。一般都用<code>KeepAlive()</code>方法</p>\n<p>KeepAlive 和 Put 一样，如果在执行之前 Lease 就已经过期了，那么需要重新分配 Lease。etcd 并没有提供 API 来实现原子的 Put with Lease，需要我们自己判断 err 重新分配 Lease。</p>\n<h3 id=\"op\">Op<a title=\"#op\" href=\"#op\"></a></h3>\n<p>Op 字面意思就是” 操作”，Get 和 Put 都属于 Op，只是为了简化用户开发而开放的特殊 API。</p>\n<p>KV 对象有一个 Do 方法接受一个 Op：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Do applies a single Op on KV without a transaction.</span><br><span class=\"line\">&#x2F;&#x2F; Do is useful when creating arbitrary operations to be issued at a</span><br><span class=\"line\">&#x2F;&#x2F; later time; the user can range over the operations, calling Do to</span><br><span class=\"line\">&#x2F;&#x2F; execute them. Get&#x2F;Put&#x2F;Delete, on the other hand, are best suited</span><br><span class=\"line\">&#x2F;&#x2F; for when the operation should be issued at the time of declaration.</span><br><span class=\"line\">Do(ctx context.Context, op Op) (OpResponse, error)</span><br></pre></td></tr></table></figure>\n<p>其参数 Op 是一个抽象的操作，可以是 Put/Get/Delete…；而 OpResponse 是一个抽象的结果，可以是 PutResponse/GetResponse…</p>\n<p>可以通过 Client 中定义的一些方法来创建 Op：</p>\n<ul>\n<li>func OpDelete(key string, opts …OpOption) Op</li>\n<li>func OpGet(key string, opts …OpOption) Op</li>\n<li>func OpPut(key, val string, opts …OpOption) Op</li>\n<li>func OpTxn(cmps []Cmp, thenOps []Op, elseOps []Op) Op</li>\n</ul>\n<p>其实和直接调用 KV.Put，KV.GET 没什么区别。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cli, err :&#x3D; clientv3.New(clientv3.Config&#123;</span><br><span class=\"line\">    Endpoints:   endpoints,</span><br><span class=\"line\">    DialTimeout: dialTimeout,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer cli.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">ops :&#x3D; []clientv3.Op&#123;</span><br><span class=\"line\">    clientv3.OpPut(&quot;put-key&quot;, &quot;123&quot;),</span><br><span class=\"line\">    clientv3.OpGet(&quot;put-key&quot;),</span><br><span class=\"line\">    clientv3.OpPut(&quot;put-key&quot;, &quot;456&quot;)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for _, op :&#x3D; range ops &#123;</span><br><span class=\"line\">    if _, err :&#x3D; cli.Do(context.TODO(), op); err !&#x3D; nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 Op 交给 Do 方法执行，返回的 opResp 结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type OpResponse struct &#123;</span><br><span class=\"line\">    put *PutResponse</span><br><span class=\"line\">    get *GetResponse</span><br><span class=\"line\">    del *DeleteResponse</span><br><span class=\"line\">    txn *TxnResponse</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你的操作是什么类型，你就用哪个指针来访问对应的结果。</p>\n<h3 id=\"txn-事务\">Txn 事务<a title=\"#txn-事务\" href=\"#txn-事务\"></a></h3>\n<p>etcd 中事务是原子执行的，只支持 if … then … else … 这种表达。首先来看一下 Txn 中定义的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Txn interface &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; If takes a list of comparison. If all comparisons passed in succeed,</span><br><span class=\"line\">    &#x2F;&#x2F; the operations passed into Then() will be executed. Or the operations</span><br><span class=\"line\">    &#x2F;&#x2F; passed into Else() will be executed.</span><br><span class=\"line\">    If(cs ...Cmp) Txn</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Then takes a list of operations. The Ops list will be executed, if the</span><br><span class=\"line\">    &#x2F;&#x2F; comparisons passed in If() succeed.</span><br><span class=\"line\">    Then(ops ...Op) Txn</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Else takes a list of operations. The Ops list will be executed, if the</span><br><span class=\"line\">    &#x2F;&#x2F; comparisons passed in If() fail.</span><br><span class=\"line\">    Else(ops ...Op) Txn</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Commit tries to commit the transaction.</span><br><span class=\"line\">    Commit() (*TxnResponse, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Txn 必须是这样使用的：If(满足条件) Then(执行若干 Op) Else(执行若干 Op)。</p>\n<p>If 中支持传入多个 Cmp 比较条件，如果所有条件满足，则执行 Then 中的 Op（上一节介绍过 Op），否则执行 Else 中的 Op。</p>\n<p>首先，我们需要开启一个事务，这是通过 KV 对象的方法实现的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txn :&#x3D; kv.Txn(context.TODO())</span><br></pre></td></tr></table></figure>\n<p>下面的测试程序，判断如果 k1 的值大于 v1 并且 k1 的版本号是 2，则 Put 键值 k2 和 k3，否则 Put 键值 k4 和 k5。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kv.Txn(context.TODO()).If(</span><br><span class=\"line\"> clientv3.Compare(clientv3.Value(k1), &quot;&gt;&quot;, v1),</span><br><span class=\"line\"> clientv3.Compare(clientv3.Version(k1), &quot;&#x3D;&quot;, 2)</span><br><span class=\"line\">).Then(</span><br><span class=\"line\"> clientv3.OpPut(k2,v2), clentv3.OpPut(k3,v3)</span><br><span class=\"line\">).Else(</span><br><span class=\"line\"> clientv3.OpPut(k4,v4), clientv3.OpPut(k5,v5)</span><br><span class=\"line\">).Commit()</span><br></pre></td></tr></table></figure>\n<p>类似于 clientv3.Value() 用于指定 key 属性的，有这么几个方法：</p>\n<ul>\n<li>func CreateRevision(key string) Cmp：key=xxx 的创建版本必须满足…</li>\n<li>func LeaseValue(key string) Cmp：key=xxx 的 Lease ID 必须满足…</li>\n<li>func ModRevision(key string) Cmp：key=xxx 的最后修改版本必须满足…</li>\n<li>func Value(key string) Cmp：key=xxx 的创建值必须满足…</li>\n<li>func Version(key string) Cmp：key=xxx 的累计更新次数必须满足…</li>\n</ul>\n<h3 id=\"watch\">Watch<a title=\"#watch\" href=\"#watch\"></a></h3>\n<p>Watch 用于监听某个键的变化, <code>Watch</code>调用后返回一个<code>WatchChan</code>，它的类型声明如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type WatchChan &lt;-chan WatchResponse</span><br><span class=\"line\"></span><br><span class=\"line\">type WatchResponse struct &#123;</span><br><span class=\"line\">    Header pb.ResponseHeader</span><br><span class=\"line\">    Events []*Event</span><br><span class=\"line\"></span><br><span class=\"line\">    CompactRevision int64</span><br><span class=\"line\"></span><br><span class=\"line\">    Canceled bool</span><br><span class=\"line\"></span><br><span class=\"line\">    Created bool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当监听的 key 有变化后会向<code>WatchChan</code>发送<code>WatchResponse</code>。Watch 的典型应用场景是应用于系统配置的热加载，我们可以在系统读取到存储在 etcd key 中的配置后，用 Watch 监听 key 的变化。在单独的 goroutine 中接收 WatchChan 发送过来的数据，并将更新应用到系统设置的配置变量中，比如像下面这样在 goroutine 中更新变量 appConfig，这样系统就实现了配置变量的热加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type AppConfig struct &#123;</span><br><span class=\"line\">  config1 string</span><br><span class=\"line\">  config2 string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var appConfig Appconfig</span><br><span class=\"line\"></span><br><span class=\"line\">func watchConfig(clt *clientv3.Client, key string, ss interface&#123;&#125;) &#123;</span><br><span class=\"line\">    watchCh :&#x3D; clt.Watch(context.TODO(), key)</span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        for res :&#x3D; range watchCh &#123;</span><br><span class=\"line\">            value :&#x3D; res.Events[0].Kv.Value</span><br><span class=\"line\">            if err :&#x3D; json.Unmarshal(value, ss); err !&#x3D; nil &#123;</span><br><span class=\"line\">                fmt.Println(&quot;now&quot;, time.Now(), &quot;watchConfig err&quot;, err)</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fmt.Println(&quot;now&quot;, time.Now(), &quot;watchConfig&quot;, ss)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">watchConfig(client, &quot;config_key&quot;, &amp;appConfig)</span><br></pre></td></tr></table></figure>\n","prev":{"title":"【golang练手】 TCP聊天程序","link":"2020/11/01/2020-11-01-1"},"next":{"title":"【go练习】一个进度条","link":"2020/10/10/2020-10-10-1"},"plink":"https://terence.segofun.com/2020/10/26/2020-10-26-01/","toc":[{"id":"etcd","title":"etcd","index":"1"},{"id":"2.etcd基础操作","title":"2.etcd基础操作","index":"2"},{"id":"3.-golang基本使用","title":"3. golang基本使用","index":"3"},{"id":"put","title":"Put","index":"4"},{"id":"get","title":"Get","index":"5"},{"id":"lease","title":"Lease","index":"6"},{"id":"op","title":"Op","index":"7"},{"id":"txn-事务","title":"Txn 事务","index":"8"},{"id":"watch","title":"Watch","index":"9"}]}