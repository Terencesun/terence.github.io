{"title":"【Go语言核心36讲】37. strings包与字符串操作","date":"2021-03-07T06:19:31.000Z","date_formatted":{"ll":"Mar 7, 2021","L":"03/07/2021","MM-DD":"03-07"},"link":"2021/03/07/2021-03-07-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-03-07T08:33:51.095Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>strings.Builder 类型的值有哪些优势？</li>\n</ol>\n<ul>\n<li>已存在的内容不可变，但可以拼接更多的内容</li>\n<li>减少了内存分配和内容拷贝的次数</li>\n<li>可将内容重置，可以重用值</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>string类型的值不可变，想要获得一个不一样的字符串，只能基于原字符串进行剪裁、拼接操作，生成一个新的字符串</p>\n</li>\n<li>\n<p>一个string值的内容会被存到一块连续的内存空间中，同时这块内容容纳的字节数量也会被记录下来，表示该string值的长度</p>\n</li>\n<li>\n<p>在一个string值上面做切片，相当于对其底层的字节数组做切片</p>\n</li>\n<li>\n<p>在做字符串拼接的时候，go会把所有被拼接的字符串依次拷贝到一个新的且足够大的内存空间中，并把持有相应指针值的string值作为结果返回</p>\n</li>\n<li>\n<p>在进行过多的拼接操作的时候，会对内存的分配产生非常大的压力</p>\n</li>\n<li>\n<p>一个string值会在底层与它的所有副本共用同一个字节数组。由于这里的字节数组永远不会被改变，所以这样做是绝对安全的</p>\n</li>\n<li>\n<p>strings.Builder值中有一个用于承载内容的容器，一个byte[]，和string的本质存储方式一样</p>\n</li>\n<li>\n<p>Builder 通过一个unsafe.Pointer类型的字段来指向字节数组的指针值，但是Builder不允许修改值</p>\n</li>\n<li>\n<p>Builder 不允许修改值，但是可以进行拼接，拼接的方法有Write，WriteByte, WriteRune, WriteString，Builder会自动扩容容器，也就是字节数组，这里的扩容策略和切片一致</p>\n</li>\n<li>\n<p>在向Builder值拼接内容的时候并不一定会引起扩容。只要内容容器的容量够用，扩容就不会进行，针对于此的内存分配也不会发生。同时，只要没有扩容，Builder值中已存在的内容就不会再被拷贝</p>\n</li>\n<li>\n<p>除了Builder值的自动扩容，我们还可以选择手动扩容，这通过调用Builder值的Grow方法就可以做到。Grow方法也可以被称为扩容方法，它接受一个int类型的参数n，该参数用于代表将要扩充的字节数量</p>\n</li>\n<li>\n<p>如有必要，Grow方法会把其所属值中内容容器的容量增加n个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原容器容量的二倍再加上n。之后，它会把原容器中的所有字节全部拷贝到新容器中</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var builder1 strings.Builder</span><br><span class=\"line\">&#x2F;&#x2F; 省略若干代码。</span><br><span class=\"line\">fmt.Println(&quot;Grow the builder ...&quot;)</span><br><span class=\"line\">builder1.Grow(10)</span><br><span class=\"line\">fmt.Printf(&quot;The length of contents in the builder is %d.\\n&quot;, builder1.Len())</span><br></pre></td></tr></table></figure>\n<ol start=\"14\">\n<li>\n<p>当前的内容容器中的未用容量已经够用了，即：未用容量大于或等于n，这个时候 Grow的方法是不会作用的</p>\n</li>\n<li>\n<p>Builder值是可以被重用的。通过调用它的Reset方法，我们可以让Builder值重新回到零值状态，就像它从未被使用过那样</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(&quot;Reset the builder ...&quot;)</span><br><span class=\"line\">builder1.Reset()</span><br><span class=\"line\">fmt.Printf(&quot;The third output(%d):\\n%q\\n&quot;, builder1.Len(), builder1.String())</span><br></pre></td></tr></table></figure>\n<ol start=\"16\">\n<li>\n<p>一旦被重用，Builder值中原有的内容容器会被直接丢弃。之后，它和其中的所有内容，将会被 Go 语言的垃圾回收器标记并回收掉</p>\n</li>\n<li>\n<p>Builder的使用是否有约束？</p>\n</li>\n</ol>\n<ul>\n<li>在已被真正使用后就不可再被复制(拼接/手动扩容算是使用)</li>\n<li>由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题</li>\n</ul>\n<ol start=\"18\">\n<li>一旦调用了它们，我们就不能再以任何的方式对其所属值进行复制了</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var builder1 strings.Builder</span><br><span class=\"line\">builder1.Grow(1)</span><br><span class=\"line\">builder3 :&#x3D; builder1</span><br><span class=\"line\">&#x2F;&#x2F;builder3.Grow(1) &#x2F;&#x2F; 这里会引发panic。</span><br><span class=\"line\">_ &#x3D; builder3</span><br></pre></td></tr></table></figure>\n<ol start=\"19\">\n<li>\n<p>约束的作用，由于builder类似于指向一个字节数组的指针(builder不是指针类型哈)，那么如果产生builder的副本之后，会让多个builder指向同一个字节数组，这样可能会导致多个builder修改同一个字节数组，所以这样做是避免冲突</p>\n</li>\n<li>\n<p>builder的指针值是可以复制的，因为这时候的指针是指向这个builder的，不是底层的字节数组</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f2 :&#x3D; func(bp *strings.Builder) &#123;</span><br><span class=\"line\"> (*bp).Grow(1) &#x2F;&#x2F; 这里虽然不会引发panic，但不是并发安全的。</span><br><span class=\"line\"> builder4 :&#x3D; *bp</span><br><span class=\"line\"> &#x2F;&#x2F;builder4.Grow(1) &#x2F;&#x2F; 这里会引发panic。</span><br><span class=\"line\"> _ &#x3D; builder4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f2(&amp;builder1)</span><br></pre></td></tr></table></figure>\n<ol start=\"21\">\n<li>\n<p>在通过传递其指针值共享Builder值的时候，一定要确保各方对它的使用是正确、有序的，并且是并发安全的；而最彻底的解决方案是，绝不共享Builder值以及它的指针值</p>\n</li>\n<li>\n<p>如何共享builder</p>\n</li>\n</ol>\n<ul>\n<li>我们可以在各处分别声明一个Builder值来使用，也可以先声明一个Builder值，然后在真正使用它之前，便将它的副本传到各处。另外，我们还可以先使用再传递，只要在传递之前调用它的Reset方法即可</li>\n<li>个人觉得没有必要，调用reset其实就是丢掉了旧的字节数组，然后builder的内容容器是空的；使用之前传递副本，这个时候内容容器是空的，字节数组还没有分配，当使用的时候，会分配字节数组内存过来</li>\n<li>最好不要共享builder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">builder1.Reset()</span><br><span class=\"line\">builder5 :&#x3D; builder1</span><br><span class=\"line\">builder5.Grow(1) &#x2F;&#x2F; 这里不会引发panic。</span><br></pre></td></tr></table></figure>\n<ol start=\"23\">\n<li>\n<p>strings.Reader 类型 是为了高效读取字符串而存在的，读取string的时候，reader会保存已读取的字节的计数</p>\n</li>\n<li>\n<p>这个已读计数也是读取回退和位置设定时的重要依据。虽然它属于Reader值的内部结构，但我们还是可以通过该值的Len方法和Size把它计算出来的</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reader1 strings.Reader</span><br><span class=\"line\">&#x2F;&#x2F; 省略若干代码。</span><br><span class=\"line\">readingIndex :&#x3D; reader1.Size() - int64(reader1.Len()) &#x2F;&#x2F; 计算出的已读计数。</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Reader值拥有的大部分用于读取的方法都会及时地更新已读计数。比如，ReadByte方法会在读取成功后将这个计数的值加1</span><br><span class=\"line\">&#x2F;&#x2F; ReadRune方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量</span><br><span class=\"line\">&#x2F;&#x2F; ReadAt方法算是一个例外，它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，这个方法可以自由地读取其所属的Reader值中的任何内容</span><br><span class=\"line\">&#x2F;&#x2F; Reader值的Seek方法也会更新该值的已读计数。实际上，这个Seek方法的主要作用正是设定下一次读取的起始索引位置</span><br></pre></td></tr></table></figure>\n","prev":{"title":"【Go语言核心36讲】38/39. bytes包与字节串操作","link":"2021/03/07/2021-03-07-02"},"next":{"title":"【Go语言核心36讲】36. unicode与字符编码","link":"2021/03/06/2021-03-06-01"},"plink":"https://terence.segofun.com/2021/03/07/2021-03-07-01/"}