{"title":"【转载】Go 项目实战：实现一个 Redis(2) 之实现 Redis 协议解析器","date":"2021-03-13T15:10:17.000Z","date_formatted":{"ll":"Mar 13, 2021","L":"03/13/2021","MM-DD":"03-13"},"link":"2021/03/13/2021-03-13-03","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.566Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://mp.weixin.qq.com/s?src=11%C3%97tamp=1615647086&amp;ver=2944&amp;signature=KJOxWs5l0IhTPhEsbi-S8YOPV5ADosbu9y56wc96yxo1uC9ObHxzeFPLOE5ExxP6psG4whQZkKVLQEMUMmafmN*FIfm87ALVkzALm3DasPA47ZbQVCYxD61*pBjvIAIO&amp;new=1\" target=\"_blank\">mp.weixin.qq.com</a></p>\n</blockquote>\n<p>本文是 《用 Golang 实现一个 Redis》系列文章第二篇，本文将分别介绍 Redis 通信协议 以及 协议解析器 的实现，若您对协议有所了解可以直接阅读协议解析器部分。</p>\n<h2 id=\"redis-通信协议\">Redis 通信协议<a title=\"#redis-通信协议\" href=\"#redis-通信协议\"></a></h2>\n<p>Redis 自 2.0 版本起使用了统一的协议 RESP (REdis Serialization Protocol)，该协议易于实现，计算机可以高效的进行解析且易于被人类读懂。</p>\n<p>RESP 是一个二进制安全的文本协议，工作于 TCP 协议上。客户端和服务器发送的命令或数据一律以 <code>\\r\\n</code> （CRLF）结尾。</p>\n<p>RESP 定义了 5 种格式：</p>\n<ul>\n<li>\n<p>简单字符串 (Simple String): 服务器用来返回简单的结果，比如 “OK”。非二进制安全，且不允许换行。</p>\n</li>\n<li>\n<p>错误信息 (Error): 服务器用来返回简单的结果，比如 “ERR Invalid Synatx”。非二进制安全，且不允许换行。</p>\n</li>\n<li>\n<p>整数 (Integer): <code>llen</code>、<code>scard</code>等命令的返回值, 64 位有符号整数</p>\n</li>\n<li>\n<p>字符串 (Bulk String): 二进制安全字符串, <code>get</code> 等命令的返回值</p>\n</li>\n<li>\n<p>数组 (Array, 旧版文档中称 Multi Bulk Strings): Bulk String 数组，客户端发送指令以及<code>lrange</code>等命令响应的格式</p>\n</li>\n</ul>\n<p>RESP 通过第一个字符来表示格式：</p>\n<ul>\n<li>\n<p>简单字符串：以 “+” 开始， 如：“+OK\\r\\n”</p>\n</li>\n<li>\n<p>错误：以 “-” 开始，如：“-ERR Invalid Synatx\\r\\n”</p>\n</li>\n<li>\n<p>整数：以 “:” 开始，如：“:1\\r\\n”</p>\n</li>\n<li>\n<p>字符串：以 <code>$</code> 开始</p>\n</li>\n<li>\n<p>数组：以 <code>*</code> 开始</p>\n</li>\n</ul>\n<p>Bulk String 有两行，第一行为 <code>$</code>+ 正文长度，第二行为实际内容。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$3\\r\\nSET\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Bulk String 是二进制安全的可以包含任意字节，就是说可以在 Bulk String 内部包含 “\\r\\n” 字符 (行尾的 CRLF 被隐藏):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$4</span><br><span class=\"line\">a\\r\\nb</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>$-1</code> 表示 nil, 比如使用 get 命令查询一个不存在的 key 时，响应即为<code>$-1</code>。</p>\n<p>Array 格式第一行为 “*”+ 数组长度，其后是相应数量的 Bulk String。如, <code>[&quot;foo&quot;, &quot;bar&quot;]</code>的报文:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*2</span><br><span class=\"line\">$3</span><br><span class=\"line\">foo</span><br><span class=\"line\">$3</span><br><span class=\"line\">bar</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>客户端也使用 Array 格式向服务端发送指令。命令本身将作为第一个参数，如 <code>SET key value</code>指令的 RESP 报文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*3</span><br><span class=\"line\">$3</span><br><span class=\"line\">SET</span><br><span class=\"line\">$3</span><br><span class=\"line\">key</span><br><span class=\"line\">$5</span><br><span class=\"line\">value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>将换行符打印出来:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nvalue\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"协议解析器\">协议解析器<a title=\"#协议解析器\" href=\"#协议解析器\"></a></h2>\n<p>我们在 <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443671&amp;idx=2&amp;sn=193ebda4599334be1e61b617e185deb7&amp;chksm=80bb0f25b7cc86337cb23c5c6f6fde6e7f837dfbaf13be86be0e046178d5e97c2662557123c5&amp;scene=21#wechat_redirect\" target=\"_blank\">实现 TCP 服务器</a> 一文中已经介绍过 TCP 服务器的实现，协议解析器将实现其 Handler 接口充当应用层服务器。</p>\n<p>协议解析器将接收 Socket 传来的数据，并将其数据还原为 <code>[][]byte</code> 格式，如 <code>&quot;*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\value\\r\\n&quot;</code> 将被还原为 <code>['SET', 'key', 'value']</code>。</p>\n<p><strong>本文完整代码: <a href=\"https://github.com/HDT3213/godis/blob/master/src/redis/handler/handler.go\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/redis/handler/handler.go</a></strong></p>\n<p>来自客户端的请求均为数组格式，它在第一行中标记报文的总行数并使用<code>CRLF</code>作为分行符。</p>\n<p><code>bufio</code> 标准库可以将从 reader 读到的数据缓存到 buffer 中，直至遇到分隔符或读取完毕后返回，所以我们使用 <code>reader.ReadBytes('\\n')</code> 来保证每次读取到完整的一行。</p>\n<p>需要注意的是 RESP 是<code>二进制安全</code>的协议，它允许在正文中使用<code>CRLF</code>字符。举例来说 Redis 可以正确接收并执行<code>SET &quot;a\\r\\nb&quot; 1</code>指令, 这条指令的正确报文是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*3</span><br><span class=\"line\">$3</span><br><span class=\"line\">SET</span><br><span class=\"line\">$4</span><br><span class=\"line\">a\\r\\nb</span><br><span class=\"line\">$7</span><br><span class=\"line\">myvalue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当 <code>ReadBytes</code> 读取到第五行 “a\\r\\nb\\r\\n” 时会将其误认为两行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*3</span><br><span class=\"line\">$3</span><br><span class=\"line\">SET</span><br><span class=\"line\">$4</span><br><span class=\"line\">a  &#x2F;&#x2F; 错误的分行</span><br><span class=\"line\">b &#x2F;&#x2F; 错误的分行</span><br><span class=\"line\">$7</span><br><span class=\"line\">myvalue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因此当读取到第四行<code>$4</code>后, 不应该继续使用 <code>ReadBytes('\\n')</code> 读取下一行, 应使用 <code>io.ReadFull(reader, msg)</code> 方法来读取指定长度的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg &#x3D; make([]byte, 4 + 2) &#x2F;&#x2F; 正文长度4 + 换行符长度2</span><br><span class=\"line\">_, err &#x3D; io.ReadFull(reader, msg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>定义 <code>Client</code> 结构体作为客户端抽象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Client struct &#123;</span><br><span class=\"line\">    &#x2F;* 与客户端的 Tcp 连接 *&#x2F;</span><br><span class=\"line\">    conn   net.Conn</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">     * 带有 timeout 功能的 WaitGroup, 用于优雅关闭</span><br><span class=\"line\">     * 当响应被完整发送前保持 waiting 状态, 阻止链接被关闭</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    waitingReply wait.Wait</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 标记客户端是否正在发送指令 *&#x2F;</span><br><span class=\"line\">    sending atomic.AtomicBool</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 客户端正在发送的参数数量, 即 Array 第一行指定的数组长度 *&#x2F;</span><br><span class=\"line\">    expectedArgsCount uint32</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 已经接收的参数数量， 即 len(args)*&#x2F;</span><br><span class=\"line\">    receivedCount uint32</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">     * 已经接收到的命令参数，每个参数由一个 []byte 表示</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    args [][]byte</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>定义解析器:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Handler struct &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">     * 记录活跃的客户端链接</span><br><span class=\"line\">     * 类型为 *Client -&gt; placeholder</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    activeConn sync.Map</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 数据库引擎，执行指令并返回结果 *&#x2F;</span><br><span class=\"line\">    db db.DB</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 关闭状态标志位，关闭过程中时拒绝新建连接和新请求 *&#x2F;</span><br><span class=\"line\">    closing atomic.AtomicBool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来可以编写主要部分了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (h *Handler)Handle(ctx context.Context, conn net.Conn) &#123;</span><br><span class=\"line\">    if h.closing.Get() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 关闭过程中不接受新连接</span><br><span class=\"line\">        _ &#x3D; conn.Close()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 初始化客户端状态 *&#x2F;</span><br><span class=\"line\">    client :&#x3D; &amp;Client &#123;</span><br><span class=\"line\">        conn:   conn,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h.activeConn.Store(client, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">    reader :&#x3D; bufio.NewReader(conn)</span><br><span class=\"line\">    var fixedLen int64 &#x3D; 0 &#x2F;&#x2F; 将要读取的 BulkString 的正文长度</span><br><span class=\"line\">    var err error</span><br><span class=\"line\">    var msg []byte</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        &#x2F;* 读取下一行数据 *&#x2F;</span><br><span class=\"line\">        if fixedLen &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 正常模式下使用 CRLF 区分数据行</span><br><span class=\"line\">            msg, err &#x3D; reader.ReadBytes(&#39;\\n&#39;)</span><br><span class=\"line\">            &#x2F;&#x2F; 判断是否以 \\r\\n 结尾</span><br><span class=\"line\">            if len(msg) &#x3D;&#x3D; 0 || msg[len(msg) - 2] !&#x3D; &#39;\\r&#39; &#123;</span><br><span class=\"line\">                errReply :&#x3D; &amp;reply.ProtocolErrReply&#123;Msg:&quot;invalid multibulk length&quot;&#125;</span><br><span class=\"line\">                _, _ &#x3D;  client.conn.Write(errReply.ToBytes())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123; &#x2F;&#x2F; 当读取到 BulkString 第二行时，根据给出的长度进行读取</span><br><span class=\"line\">            msg &#x3D; make([]byte, fixedLen + 2)</span><br><span class=\"line\">            _, err &#x3D; io.ReadFull(reader, msg)</span><br><span class=\"line\">            &#x2F;&#x2F; 判断是否以 \\r\\n 结尾</span><br><span class=\"line\">            if len(msg) &#x3D;&#x3D; 0 ||</span><br><span class=\"line\">              msg[len(msg) - 2] !&#x3D; &#39;\\r&#39; ||</span><br><span class=\"line\">              msg[len(msg) - 1] !&#x3D; &#39;\\n&#39;&#123;</span><br><span class=\"line\">                errReply :&#x3D; &amp;reply.ProtocolErrReply&#123;Msg:&quot;invalid multibulk length&quot;&#125;</span><br><span class=\"line\">                _, _ &#x3D;  client.conn.Write(errReply.ToBytes())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; Bulk String 读取完毕，重新使用正常模式</span><br><span class=\"line\">            fixedLen &#x3D; 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 处理 IO 异常</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            if err &#x3D;&#x3D; io.EOF || err &#x3D;&#x3D; io.ErrUnexpectedEOF &#123;</span><br><span class=\"line\">                logger.Info(&quot;connection close&quot;)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                logger.Warn(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ &#x3D; client.Close()</span><br><span class=\"line\">            h.activeConn.Delete(client)</span><br><span class=\"line\">            return &#x2F;&#x2F; io error, disconnect with client</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;* 解析收到的数据 *&#x2F;</span><br><span class=\"line\">        if !client.sending.Get() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; sending &#x3D;&#x3D; false 表明收到了一条新指令</span><br><span class=\"line\">            if msg[0] &#x3D;&#x3D; &#39;*&#39; &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 读取第一行获取参数个数</span><br><span class=\"line\">                expectedLine, err :&#x3D; strconv.ParseUint(string(msg[1:len(msg)-2]), 10, 32)</span><br><span class=\"line\">                if err !&#x3D; nil &#123;</span><br><span class=\"line\">                    _, _ &#x3D; client.conn.Write(UnknownErrReplyBytes)</span><br><span class=\"line\">                    continue</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F; 初始化客户端状态</span><br><span class=\"line\">                client.waitingReply.Add(1) &#x2F;&#x2F; 有指令未处理完成，阻止服务器关闭</span><br><span class=\"line\">                client.sending.Set(true) &#x2F;&#x2F; 正在接收指令中</span><br><span class=\"line\">                &#x2F;&#x2F; 初始化计数器和缓冲区</span><br><span class=\"line\">                client.expectedArgsCount &#x3D; uint32(expectedLine)</span><br><span class=\"line\">                client.receivedCount &#x3D; 0</span><br><span class=\"line\">                client.args &#x3D; make([][]byte, expectedLine)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; TODO: text protocol</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 收到了指令的剩余部分（非首行）</span><br><span class=\"line\">            line :&#x3D; msg[0:len(msg)-2] &#x2F;&#x2F; 移除换行符</span><br><span class=\"line\">            if line[0] &#x3D;&#x3D; &#39;$&#39; &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; BulkString 的首行，读取String长度</span><br><span class=\"line\">                fixedLen, err &#x3D; strconv.ParseInt(string(line[1:]), 10, 64)</span><br><span class=\"line\">                if err !&#x3D; nil &#123;</span><br><span class=\"line\">                    errReply :&#x3D; &amp;reply.ProtocolErrReply&#123;Msg:err.Error()&#125;</span><br><span class=\"line\">                    _, _ &#x3D; client.conn.Write(errReply.ToBytes())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if fixedLen &lt;&#x3D; 0 &#123;</span><br><span class=\"line\">                    errReply :&#x3D; &amp;reply.ProtocolErrReply&#123;Msg:&quot;invalid multibulk length&quot;&#125;</span><br><span class=\"line\">                    _, _ &#x3D; client.conn.Write(errReply.ToBytes())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 收到参数</span><br><span class=\"line\">                client.args[client.receivedCount] &#x3D; line</span><br><span class=\"line\">                client.receivedCount++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F; 一条命令发送完毕</span><br><span class=\"line\">            if client.receivedCount &#x3D;&#x3D; client.expectedArgsCount &#123;</span><br><span class=\"line\">                client.sending.Set(false)</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 执行命令并响应</span><br><span class=\"line\">                result :&#x3D; h.db.Exec(client.args)</span><br><span class=\"line\">                if result !&#x3D; nil &#123;</span><br><span class=\"line\">                    _, _ &#x3D; conn.Write(result.ToBytes())</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    _, _ &#x3D; conn.Write(UnknownErrReplyBytes)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 重置客户端状态，等待下一条指令</span><br><span class=\"line\">                client.expectedArgsCount &#x3D; 0</span><br><span class=\"line\">                client.receivedCount &#x3D; 0</span><br><span class=\"line\">                client.args &#x3D; nil</span><br><span class=\"line\">                client.waitingReply.Done()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作者：finley</p>\n<p>出处：<a href=\"https://www.cnblogs.com/Finley/p/11923168.html\" target=\"_blank\">https://www.cnblogs.com/Finley/p/11923168.html</a></p>\n<p>版权：本作品采用「署名 - 非商业性使用 - 相同方式共享 4.0 国际」许可协议进行许可。</p>\n</blockquote>\n<p><strong>推荐阅读</strong></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443671&amp;idx=2&amp;sn=193ebda4599334be1e61b617e185deb7&amp;chksm=80bb0f25b7cc86337cb23c5c6f6fde6e7f837dfbaf13be86be0e046178d5e97c2662557123c5&amp;scene=21#wechat_redirect\" target=\"_blank\">Go 项目实战：实现一个 Redis (1) 之编写 TCP 服务器</a></strong></p>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis(3) 之实现内存数据库","link":"2021/03/13/2021-03-13-04"},"next":{"title":"【转载】Go 项目实战：实现一个 Redis (1) 之编写 TCP 服务器","link":"2021/03/13/2021-03-13-02"},"plink":"https://terence.segofun.com/2021/03/13/2021-03-13-03/","toc":[{"id":"redis-通信协议","title":"Redis 通信协议","index":"1"},{"id":"协议解析器","title":"协议解析器","index":"2"}],"reading_time":"2001 words in 13 min"}