{"title":"【转载】Go 项目实战：实现一个 Redis(4) 之 AOF 持久化与 AOF 重写","date":"2021-03-13T16:17:42.000Z","date_formatted":{"ll":"Mar 14, 2021","L":"03/14/2021","MM-DD":"03-14"},"link":"2021/03/14/2021-03-13-05","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.566Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://mp.weixin.qq.com/s?src=11%C3%97tamp=1615648497&amp;ver=2944&amp;signature=KJOxWs5l0IhTPhEsbi-S8YOPV5ADosbu9y56wc96yxq3A2m80LzfCN5mxFq8cDcyDFn*TnQOi7Lo484LxBgJySsKq5i7a2wArr5qVWGQO6hA-8aCBgBCJEYF4X9tKtPz&amp;new=1\" target=\"_blank\">mp.weixin.qq.com</a></p>\n</blockquote>\n<p>本文是使用 golang 实现 redis 系列的第四篇文章，将介绍如何使用 golang 实现 Append Only File 持久化及 AOF 文件重写。</p>\n<p>本文完整源代码在作者 Github：<a href=\"https://github.com/HDT3213/godis/blob/master/src/db/aof.go\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/db/aof.go</a></p>\n<h2 id=\"aof-文件\">AOF 文件<a title=\"#aof-文件\" href=\"#aof-文件\"></a></h2>\n<p>AOF 持久化是典型的异步任务，主协程 (goroutine) 可以使用 channel 将数据发送到异步协程由异步协程执行持久化操作。</p>\n<p>在 DB 中定义相关字段:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type DB struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 主线程使用此channel将要持久化的命令发送到异步协程</span><br><span class=\"line\">    aofChan     chan *reply.MultiBulkReply </span><br><span class=\"line\">    &#x2F;&#x2F; append file 文件描述符</span><br><span class=\"line\">    aofFile     *os.File  </span><br><span class=\"line\">    &#x2F;&#x2F; append file 路径</span><br><span class=\"line\">  aofFilename string </span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; aof 重写需要的缓冲区，将在AOF重写一节详细介绍</span><br><span class=\"line\">    aofRewriteChan chan *reply.MultiBulkReply </span><br><span class=\"line\">    &#x2F;&#x2F; 在必要的时候使用此字段暂停持久化操作</span><br><span class=\"line\">  pausingAof     sync.RWMutex </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在进行持久化时需要注意两个细节:</p>\n<ol>\n<li>\n<p>get 之类的读命令并不需要进行持久化</p>\n</li>\n<li>\n<p>expire 命令要用等效的 expireat 命令替换。举例说明，10:00 执行 <code>expire a 3600</code> 表示键 a 在 11:00 过期，在 10:30 载入 AOF 文件时执行 <code>expire a 3600</code> 就成了 11:30 过期与原数据不符。</p>\n</li>\n</ol>\n<p>我们在命令处理方法中返回 AOF 需要的额外信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type extra struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 表示该命令是否需要持久化</span><br><span class=\"line\">    toPersist  bool </span><br><span class=\"line\">    &#x2F;&#x2F; 如上文所述 expire 之类的命令不能直接持久化</span><br><span class=\"line\">    &#x2F;&#x2F; 若 specialAof &#x3D;&#x3D; nil 则将命令原样持久化，否则持久化 specialAof 中的指令</span><br><span class=\"line\">  specialAof []*reply.MultiBulkReply </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type CmdFunc func(db *DB, args [][]byte) (redis.Reply, *extra)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以 SET 命令为例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Set(db *DB, args [][]byte) (redis.Reply, *extra) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;....</span><br><span class=\"line\">    var result int</span><br><span class=\"line\">    switch policy &#123;</span><br><span class=\"line\">    case upsertPolicy:</span><br><span class=\"line\">        result &#x3D; db.Put(key, entity)</span><br><span class=\"line\">    case insertPolicy:</span><br><span class=\"line\">        result &#x3D; db.PutIfAbsent(key, entity)</span><br><span class=\"line\">    case updatePolicy:</span><br><span class=\"line\">        result &#x3D; db.PutIfExists(key, entity)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    extra :&#x3D; &amp;extra&#123;toPersist: result &gt; 0&#125; &#x2F;&#x2F; 若实际写入了数据则toPresist&#x3D;true, 若因为XX或NX选项没有实际写入数据则toPresist&#x3D;false</span><br><span class=\"line\">    if result &gt; 0 &#123;</span><br><span class=\"line\">        if ttl !&#x3D; unlimitedTTL &#123; &#x2F;&#x2F; 使用了 EX 或 NX 选项</span><br><span class=\"line\">            expireTime :&#x3D; time.Now().Add(time.Duration(ttl) * time.Millisecond)</span><br><span class=\"line\">            db.Expire(key, expireTime)</span><br><span class=\"line\">            &#x2F;&#x2F; 持久化时使用 set key value 和 pexpireat 命令代替 set key value EX ttl 命令</span><br><span class=\"line\">            extra.specialAof &#x3D; []*reply.MultiBulkReply&#123; </span><br><span class=\"line\">                reply.MakeMultiBulkReply([][]byte&#123;</span><br><span class=\"line\">                    []byte(&quot;SET&quot;),</span><br><span class=\"line\">                    args[0],</span><br><span class=\"line\">                    args[1],</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                makeExpireCmd(key, expireTime),</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            db.Persist(key) &#x2F;&#x2F; override ttl</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &amp;reply.OkReply&#123;&#125;, extra</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var pExpireAtCmd &#x3D; []byte(&quot;PEXPIREAT&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">func makeExpireCmd(key string, expireAt time.Time) *reply.MultiBulkReply &#123;</span><br><span class=\"line\">  args :&#x3D; make([][]byte, 3)</span><br><span class=\"line\">  args[0] &#x3D; pExpireAtCmd</span><br><span class=\"line\">  args[1] &#x3D; []byte(key)</span><br><span class=\"line\">  args[2] &#x3D; []byte(strconv.FormatInt(expireAt.UnixNano()&#x2F;1e6, 10))</span><br><span class=\"line\">  return reply.MakeMultiBulkReply(args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在处理命令的调度方法中将 aof 命令发送到 channel:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) Exec(c redis.Client, args [][]byte) (result redis.Reply) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ....</span><br><span class=\"line\">  &#x2F;&#x2F; normal commands</span><br><span class=\"line\">  var extra *extra</span><br><span class=\"line\">  cmdFunc, ok :&#x3D; router[cmd] &#x2F;&#x2F; 找到命令对应的处理函数</span><br><span class=\"line\">  if !ok &#123;</span><br><span class=\"line\">    return reply.MakeErrReply(&quot;ERR unknown command &#39;&quot; + cmd + &quot;&#39;&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 使用处理函数执行命令</span><br><span class=\"line\">  if len(args) &gt; 1 &#123;</span><br><span class=\"line\">    result, extra &#x3D; cmdFunc(db, args[1:])</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    result, extra &#x3D; cmdFunc(db, [][]byte&#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; AOF 持久化</span><br><span class=\"line\">  if config.Properties.AppendOnly &#123;</span><br><span class=\"line\">    if extra !&#x3D; nil &amp;&amp; extra.toPersist &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 写入 specialAof</span><br><span class=\"line\">      if extra.specialAof !&#x3D; nil &amp;&amp; len(extra.specialAof) &gt; 0 &#123;</span><br><span class=\"line\">        for _, r :&#x3D; range extra.specialAof &#123;</span><br><span class=\"line\">          db.addAof(r)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 写入原始命令</span><br><span class=\"line\">        r :&#x3D; reply.MakeMultiBulkReply(args)</span><br><span class=\"line\">        db.addAof(r)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在异步协程中写入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) handleAof() &#123;</span><br><span class=\"line\">  for cmd :&#x3D; range db.aofChan &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 异步协程在持久化之前会尝试获取锁，若其他协程持有锁则会暂停持久化操作</span><br><span class=\"line\">        &#x2F;&#x2F; 锁也保证了每次写入完整的一条指令不会格式错误</span><br><span class=\"line\">    db.pausingAof.RLock() </span><br><span class=\"line\">    if db.aofRewriteChan !&#x3D; nil &#123;</span><br><span class=\"line\">      db.aofRewriteChan &lt;- cmd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _, err :&#x3D; db.aofFile.Write(cmd.ToBytes())</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">      logger.Warn(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    db.pausingAof.RUnlock()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>读取过程与协议解析器 [1] 一节基本相同，不在正文中赘述：loadAof <a href=\"https://github.com/HDT3213/godis/blob/master/src/db/aof.go%E3%80%82\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/db/aof.go。</a></p>\n<h2 id=\"aof-重写\">AOF 重写<a title=\"#aof-重写\" href=\"#aof-重写\"></a></h2>\n<p>若我们对键 a 赋值 100 次会在 AOF 文件中产生 100 条指令但只有最后一条指令是有效的，为了减少持久化文件的大小需要进行 AOF 重写以删除无用的指令。</p>\n<p>重写必须在固定不变的数据集上进行，不能直接使用内存中的数据。Redis 重写的实现方式是进行 fork 并在子进程中遍历数据库内的数据重新生成 AOF 文件。由于 golang 不支持 fork 操作，我们只能采用读取 AOF 文件生成副本的方式来代替 fork。</p>\n<p>在进行 AOF 重写操作时需要满足两个要求:</p>\n<ol>\n<li>\n<p>若 AOF 重写失败或被中断，AOF 文件需保持重写之前的状态不能丢失数据</p>\n</li>\n<li>\n<p>进行 AOF 重写期间执行的命令必须保存到新的 AOF 文件中, 不能丢失</p>\n</li>\n</ol>\n<p>因此我们设计了一套比较复杂的流程：</p>\n<ol>\n<li>\n<p>暂停 AOF 写入 -&gt; 更改状态为重写中 -&gt; 准备重写 -&gt; 恢复 AOF 写入</p>\n</li>\n<li>\n<p>在重写过程中，持久化协程在将命令写入文件的同时也将其写入内存中的重写缓存区</p>\n</li>\n<li>\n<p>重写协程读取 AOF 文件中的前一部分（重写开始前的数据，不包括读写过程中写入的数据）并重写到临时文件（tmp.aof）中</p>\n</li>\n<li>\n<p>暂停 AOF 写入 -&gt; 将重写缓冲区中的命令写入 tmp.aof -&gt; 使用临时文件 tmp.aof 覆盖 AOF 文件（使用文件系统的 mv 命令保证安全）-&gt; 清空重写缓冲区 -&gt; 恢复 AOF 写入</p>\n</li>\n</ol>\n<blockquote>\n<p>在不阻塞在线服务的同时进行其它操作是一项必需的能力，AOF 重写的思路在解决这类问题时具有重要的参考价值。比如 Mysql Online DDL: gh-ost[2] 采用了类似的策略保证数据一致。</p>\n</blockquote>\n<p>首先准备开始重写操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) startRewrite() (*os.File, int64, error) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 暂停AOF写入， 数据会在 db.aofChan 中暂时堆积</span><br><span class=\"line\">  db.pausingAof.Lock() </span><br><span class=\"line\">  defer db.pausingAof.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建重写缓冲区  </span><br><span class=\"line\">  db.aofRewriteChan &#x3D; make(chan *reply.MultiBulkReply, aofQueueSize)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 读取当前 aof 文件大小, 不读取重写过程中新写入的内容</span><br><span class=\"line\">  fileInfo, _ :&#x3D; os.Stat(db.aofFilename)</span><br><span class=\"line\">  filesize :&#x3D; fileInfo.Size()</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建临时文件</span><br><span class=\"line\">  file, err :&#x3D; ioutil.TempFile(&quot;&quot;, &quot;aof&quot;)</span><br><span class=\"line\">  if err !&#x3D; nil &#123;</span><br><span class=\"line\">    logger.Warn(&quot;tmp file create failed&quot;)</span><br><span class=\"line\">    return nil, 0, err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return file, filesize, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在重写过程中，持久化协程进行双写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) handleAof() &#123;</span><br><span class=\"line\">  for cmd :&#x3D; range db.aofChan &#123;</span><br><span class=\"line\">    db.pausingAof.RLock() </span><br><span class=\"line\">    if db.aofRewriteChan !&#x3D; nil &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 数据写入重写缓冲区</span><br><span class=\"line\">      db.aofRewriteChan &lt;- cmd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _, err :&#x3D; db.aofFile.Write(cmd.ToBytes())</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">      logger.Warn(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    db.pausingAof.RUnlock()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行重写:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) aofRewrite() &#123;</span><br><span class=\"line\">  file, fileSize, err :&#x3D; db.startRewrite()</span><br><span class=\"line\">  if err !&#x3D; nil &#123;</span><br><span class=\"line\">    logger.Warn(err)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; load aof file</span><br><span class=\"line\">  tmpDB :&#x3D; &amp;DB&#123;</span><br><span class=\"line\">    Data:     dict.MakeSimple(),</span><br><span class=\"line\">    TTLMap:   dict.MakeSimple(),</span><br><span class=\"line\">    Locker:   lock.Make(lockerSize),</span><br><span class=\"line\">    interval: 5 * time.Second,</span><br><span class=\"line\"></span><br><span class=\"line\">    aofFilename: db.aofFilename,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 只读取开始重写前 aof 文件的内容</span><br><span class=\"line\">  tmpDB.loadAof(int(fileSize))</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; rewrite aof file</span><br><span class=\"line\">  tmpDB.Data.ForEach(func(key string, raw interface&#123;&#125;) bool &#123;</span><br><span class=\"line\">    var cmd *reply.MultiBulkReply</span><br><span class=\"line\">    entity, _ :&#x3D; raw.(*DataEntity)</span><br><span class=\"line\">    switch val :&#x3D; entity.Data.(type) &#123;</span><br><span class=\"line\">    case []byte:</span><br><span class=\"line\">      cmd &#x3D; persistString(key, val)</span><br><span class=\"line\">    case *List.LinkedList:</span><br><span class=\"line\">      cmd &#x3D; persistList(key, val)</span><br><span class=\"line\">    case *set.Set:</span><br><span class=\"line\">      cmd &#x3D; persistSet(key, val)</span><br><span class=\"line\">    case dict.Dict:</span><br><span class=\"line\">      cmd &#x3D; persistHash(key, val)</span><br><span class=\"line\">    case *SortedSet.SortedSet:</span><br><span class=\"line\">      cmd &#x3D; persistZSet(key, val)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if cmd !&#x3D; nil &#123;</span><br><span class=\"line\">      _, _ &#x3D; file.Write(cmd.ToBytes())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  tmpDB.TTLMap.ForEach(func(key string, raw interface&#123;&#125;) bool &#123;</span><br><span class=\"line\">    expireTime, _ :&#x3D; raw.(time.Time)</span><br><span class=\"line\">    cmd :&#x3D; makeExpireCmd(key, expireTime)</span><br><span class=\"line\">    if cmd !&#x3D; nil &#123;</span><br><span class=\"line\">      _, _ &#x3D; file.Write(cmd.ToBytes())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  db.finishRewrite(file)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>重写完毕后写入缓冲区中的数据并替换正式文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) finishRewrite(tmpFile *os.File) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 暂停AOF写入</span><br><span class=\"line\">  db.pausingAof.Lock() </span><br><span class=\"line\">  defer db.pausingAof.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将重写缓冲区内的数据写入临时文件</span><br><span class=\"line\">  &#x2F;&#x2F; 因为handleAof已被暂停，在遍历期间aofRewriteChan中不会有新数据</span><br><span class=\"line\">    loop:</span><br><span class=\"line\">  for &#123;</span><br><span class=\"line\">    select &#123;</span><br><span class=\"line\">    case cmd :&#x3D; &lt;-db.aofRewriteChan:</span><br><span class=\"line\">      _, err :&#x3D; tmpFile.Write(cmd.ToBytes())</span><br><span class=\"line\">      if err !&#x3D; nil &#123;</span><br><span class=\"line\">        logger.Warn(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      &#x2F;&#x2F; 只有 channel 为空时才会进入此分支</span><br><span class=\"line\">      break loop</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 释放重写缓冲区</span><br><span class=\"line\">  close(db.aofRewriteChan)</span><br><span class=\"line\">  db.aofRewriteChan &#x3D; nil</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 使用临时文件代替aof文件</span><br><span class=\"line\">  _ &#x3D; db.aofFile.Close()</span><br><span class=\"line\">  _ &#x3D; os.Rename(tmpFile.Name(), db.aofFilename)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 重新打开文件描述符以保证正常写入</span><br><span class=\"line\">  aofFile, err :&#x3D; os.OpenFile(db.aofFilename, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0600)</span><br><span class=\"line\">  if err !&#x3D; nil &#123;</span><br><span class=\"line\">    panic(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.aofFile &#x3D; aofFile</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作者：finley</p>\n<p>出处：<a href=\"https://www.cnblogs.com/Finley/p/12663636.html\" target=\"_blank\">https://www.cnblogs.com/Finley/p/12663636.html</a></p>\n<p>版权：本作品采用「署名 - 非商业性使用 - 相同方式共享 4.0 国际 [3]」许可协议进行许可。</p>\n</blockquote>\n<h3 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h3>\n<p>[1] 协议解析器: _<a href=\"https://www.cnblogs.com/Finley/p/11923168.html_\" target=\"_blank\">https://www.cnblogs.com/Finley/p/11923168.html_</a></p>\n<p>[2] Mysql Online DDL: gh-ost: _<a href=\"https://github.com/github/gh-ost_\" target=\"_blank\">https://github.com/github/gh-ost_</a></p>\n<p><strong>推荐阅读</strong></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443997&amp;idx=2&amp;sn=64a66d1ad920a4b730ed5f4e537e2450&amp;chksm=80bb0defb7cc84f93944740df4b5b7caed86f2a0437404b39b291d00a64e0d8b1439e60dd0d9&amp;scene=21#wechat_redirect\" target=\"_blank\">Go 项目实战：实现一个 Redis(3) 之实现内存数据库</a></strong></p>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis(5) 之使用跳表实现 SortedSet","link":"2021/03/14/2021-03-13-06"},"next":{"title":"【转载】Go 项目实战：实现一个 Redis(3) 之实现内存数据库","link":"2021/03/13/2021-03-13-04"},"plink":"https://terence.segofun.com/2021/03/14/2021-03-13-05/","toc":[{"id":"aof-文件","title":"AOF 文件","index":"1"},{"id":"aof-重写","title":"AOF 重写","index":"2","children":[{"id":"参考资料","title":"参考资料","index":"2.1"}]}],"reading_time":"2218 words in 15 min"}