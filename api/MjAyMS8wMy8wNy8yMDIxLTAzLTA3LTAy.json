{"title":"【Go语言核心36讲】38/39. bytes包与字节串操作","date":"2021-03-07T08:34:12.000Z","date_formatted":{"ll":"Mar 7, 2021","L":"03/07/2021","MM-DD":"03-07"},"link":"2021/03/07/2021-03-07-02","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-03-07T15:52:09.463Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>strings包和bytes包很相似，strings包主要面向的是Unicode字符和经过utf8编码的字符串，bytes包面对的则主要是字节和字节切片</p>\n</li>\n<li>\n<p>bytes.Buffer和strings.Builder类似，但是，bytes.Buffer不但可以拼接和截断字节序列，还能导出内容、顺序读取其中的子序列等工作</p>\n</li>\n<li>\n<p>与strings.Builder类型，Buffer类型也有一个int类型的字段，用于代表已读字节的计数，但是这里buffer的已读计数无法通过buffer提供的方法计算出来</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer1 bytes.Buffer</span><br><span class=\"line\">contents :&#x3D; &quot;Simple byte buffer for marshaling data.&quot;</span><br><span class=\"line\">fmt.Printf(&quot;Writing contents %q ...\\n&quot;, contents)</span><br><span class=\"line\">buffer1.WriteString(contents)</span><br><span class=\"line\">fmt.Printf(&quot;The length of buffer: %d\\n&quot;, buffer1.Len())</span><br><span class=\"line\">fmt.Printf(&quot;The capacity of buffer: %d\\n&quot;, buffer1.Cap())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Writing contents &quot;Simple byte buffer for marshaling data.&quot; ...</span><br><span class=\"line\">&#x2F;&#x2F; The length of buffer: 39</span><br><span class=\"line\">&#x2F;&#x2F; The capacity of buffer: 64</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 64是自动扩容策略所得到的容量</span><br><span class=\"line\">&#x2F;&#x2F; buffer1的Len方法返回的也是内容容器中未被读取部分的长度</span><br><span class=\"line\">&#x2F;&#x2F; Buffer值的长度是未读内容的长度，而不是已存内容的总长度</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>\n<p>strings.Reader有一个size方法可以给出内容长度，但是bytes.Buffer类型没有这种方法，只有cap方法，只能得到容量，但是容量是会变化的</p>\n</li>\n<li>\n<p>buffer类型里面，有个off的私有计数，记录的是已读计数，这个已读计数的作用是</p>\n</li>\n</ol>\n<ul>\n<li>读取内容，依据已读计数找到未读部分，读取后更新计数</li>\n<li>写入内容，如果扩容了，对应的方法根据已读计数实现扩容策略</li>\n<li>截断内容，截掉的是已读计数代表的索引之后的未读部分</li>\n<li>读回退时，需要用已读计数记录回退点</li>\n<li>重置内容，需要把已读计数置为0</li>\n<li>到处内容，对应的方法只会到出已读计数代表的索引之后的未读部分</li>\n<li>获取长度，响应的方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回</li>\n</ul>\n<ol start=\"6\">\n<li>\n<p>UnreadByte和UnreadRune是两个回退操作，一个是回退一个字节，一个是回退一个unicode字符</p>\n</li>\n<li>\n<p>回退操作由两步组成，读取和修改，读取是读取出前一个字节或一个unicode字符，读取成功了，才能修改已读计数的值，否则会报错</p>\n</li>\n<li>\n<p>unreadByte直接把已读计数减一，而unreadRune需要减去上一个已读字符的字节数</p>\n</li>\n<li>\n<p>bytes.Buffer的扩容策略</p>\n</li>\n</ol>\n<ul>\n<li>判断内容容器的剩余容量，是否可以满足调用方的要求，或者是否足够容纳新的内容</li>\n<li>如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充</li>\n<li>如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.buf &#x3D; b.buf[:length+need]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容</li>\n<li>优化：如果当前内容容器的容量的一半，仍然大于或等于其现有长度+需要的字节数的和，那么扩容就会复用现有的内容容器，并把容器中的维度内容拷贝到它的头部位置</li>\n<li>意味着已读内容，将会全部被维度内容和之后的新内容覆盖掉，从而节省内存分配</li>\n<li>如果这一步优化未能达成，就需要创建一个新的内容容器，且新容器的容量 = 2 * 原有容量+新进来的内容的字节数(也就是所需字节数)</li>\n<li>扩容最后，会将已读计数置为0，然后把原来已读的内容弄掉</li>\n</ul>\n<ol start=\"10\">\n<li>bytes.Buffer哪些方法可能会造成内容泄露？</li>\n</ol>\n<ul>\n<li>Bytes和Next方法，可能会造成内容的泄露，因为他们都把基于内容容器的切片直接返回给了调用方</li>\n</ul>\n","next":{"title":"【Go语言核心36讲】37. strings包与字符串操作","link":"2021/03/07/2021-03-07-01"},"plink":"https://terence.segofun.com/2021/03/07/2021-03-07-02/"}