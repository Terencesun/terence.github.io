{"title":"【Go语言核心36讲】19/20. 错误处理","date":"2021-02-18T13:19:38.000Z","date_formatted":{"ll":"Feb 18, 2021","L":"02/18/2021","MM-DD":"02-18"},"link":"2021/02/18/2021-02-18-03","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-19T01:11:22.484Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>error类型是一个接口类型，也是一个Go语言内建类型</p>\n</li>\n<li>\n<p>对于其他类型的值来说，只要我们能为这个类型编写一个String方法，就可以自定义它的字符串表示形式。而对于error类型值，它的字符串表示形式则取决于它的Error方法</p>\n</li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">errors.New(&quot;xxxx&quot;)</span><br><span class=\"line\">&#x2F;&#x2F; 这个错误的静态类型当然是error，而动态类型则是一个在errors包中的，包级私有的类型*errorString</span><br><span class=\"line\">&#x2F;&#x2F; errorString类型拥有的一个指针方法实现了error接口中的Error方法。这个方法在被调用后，会原封不动地返回我们之前传入的错误信息</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>对于具体错误的判断，Go 语言中都有哪些惯用法？</li>\n</ol>\n<ul>\n<li>对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断；</li>\n<li>对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；</li>\n<li>对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 对于os的几种常见错误</span><br><span class=\"line\">&#x2F;&#x2F; os.PathError、os.LinkError、os.SyscallError和os&#x2F;exec.Error来说，它们的指针类型都是error接口的实现类型，同时它们也都包含了一个名叫Err，类型为error接口类型的代表潜在错误的字段</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func underlyingError(err error) error &#123;</span><br><span class=\"line\">  switch err :&#x3D; err.(type) &#123;</span><br><span class=\"line\">  case *os.PathError:</span><br><span class=\"line\">    return err.Err</span><br><span class=\"line\">  case *os.LinkError:</span><br><span class=\"line\">    return err.Err</span><br><span class=\"line\">  case *os.SyscallError:</span><br><span class=\"line\">    return err.Err</span><br><span class=\"line\">  case *exec.Error:</span><br><span class=\"line\">    return err.Err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 这里使用了断言来进行错误类型判断，注意这里返回的是还原指针</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>构建错误值体系的基本方式：构建立体的错误类型体系和创建扁平的错误值列表</p>\n</li>\n<li>\n<p>错误类型体系：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 比如net包中，有个Error的接口类型，net.Error</span><br><span class=\"line\">&#x2F;&#x2F; 内建接口error是树根，net.Error就扣就是在根上延伸的第一级非叶子节点</span><br><span class=\"line\">&#x2F;&#x2F; 当net包使用时拿到一个错误值的时候，可以先判断它是否是net.Error类型的，也就是说是否代表了一个网络相关的错误</span><br><span class=\"line\">&#x2F;&#x2F; 然后就可以进一步判断它的更具体的错误类型，比如是因为网络地址引起的还是网络协议不正确引起的</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>错误值类型之间的链式关系：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; net包中的具体错误类型实现的是，有Err，类型为error接口类型的字段，代表的是当前错误的潜在错误</span><br><span class=\"line\">&#x2F;&#x2F; 比如调用net.DialTCP之类的函数时，net包中的代码可能会返回一个*net.OpError类型的错误值，表示操作不当造成错误</span><br><span class=\"line\">&#x2F;&#x2F; 同时，可能还会把一个*net.AddrError等类型的值给Err字段，表示导致这个错误的潜在原因</span><br><span class=\"line\">&#x2F;&#x2F; 如果*net.AddrError等这些值的Err字段有非nil得值，表明有更深层的错误原因，像链条一样</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>如果不想让包外代码改动返回的错误值的话，可以小写，当外部需要做错误的判等操作的时候，可以在包内写一些判断用的函数</li>\n</ol>\n<ul>\n<li>比如，对于错误值os.ErrClosed，先改写它的名称，让其变成os.errClosed，然后再编写ErrClosed函数和IsErrClosed函数</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】21/22. panic函数、recover函数以及defer语句","link":"2021/02/18/2021-02-18-04"},"next":{"title":"【Go语言核心36讲】18. if语句、for语句和switch语句","link":"2021/02/18/2021-02-18-02"},"plink":"https://terence.segofun.com/2021/02/18/2021-02-18-03/"}