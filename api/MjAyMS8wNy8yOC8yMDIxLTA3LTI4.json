{"title":"【Go语言项目开发】08/09 研发流程设计","date":"2021-07-28T06:45:04.000Z","date_formatted":{"ll":"Jul 28, 2021","L":"07/28/2021","MM-DD":"07-28"},"link":"2021/07/28/2021-07-28","comments":true,"tags":["golang"],"updated":"2022-10-17T01:08:12.570Z","content":"<ol>\n<li>不合理研发流程带来的问题</li>\n</ol>\n<ul>\n<li>代码管理混乱 -&gt; 合并代码时出现合错、合丢、代码冲突等问题</li>\n<li>研发效率低 -&gt; 编译、测试、静态代码检查等全靠手动操作，效率低下</li>\n<li>发布效率低 -&gt; 发布周期长，以及发布不规范造成的现网问题频发</li>\n</ul>\n<ol start=\"2\">\n<li>在设计研发流程时，需要关注哪些点</li>\n</ol>\n<ul>\n<li>发布效率高：研发流程应该能提高发布效率，减少发布时间和人工介入的工作量</li>\n<li>发布质量高：研发流程应该能够提高发布质量，确保发布出去的代码是经过充分测试的，并且完全避免人为因素造成的故障</li>\n<li>迭代速度快：整个研发流程要能支持快速迭代，产品迭代速度越快，意味着产品的竞争力越强，在互联网时代越能把握先机</li>\n<li>明确性：整个研发流程中角色的职责、使用的工具、方法和流程都应该是明确的，这可以增强流程的可执行性</li>\n<li>流程合理：研发流程最终是供产品、开发、测试、运维等人员使用的，所以整个流程设计不能是反人类的，要能够被各类参与人员接受并执行</li>\n<li>柔性扩展：研发流程应该是柔性且可扩展的，能够灵活变通，并适应各类场景</li>\n<li>输入输出：研发流程中的每个阶段都应该有明确的输入和输出，这些输入和输出标志着上一个阶段的完成，下一个阶段的开始</li>\n</ul>\n<ol start=\"3\">\n<li>业界相对标准的划分，是把研发流程分为六个阶段，分别是需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段</li>\n</ol>\n<p><img src=\"../images/store/2D70Jn.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ol start=\"4\">\n<li>\n<p>每个阶段结束时，都需要有一个最终的产出物，可以是文档、代码或者部署组件等</p>\n</li>\n<li>\n<p>在完成任务的过程中，可能需要经过多轮的讨论、修改，最终形成定稿。</p>\n</li>\n<li>\n<p>各阶段产物</p>\n</li>\n</ol>\n<ul>\n<li>需求阶段的产出物是一个通过评审的详细的需求文档</li>\n<li>设计阶段的产出物是一系列的设计文档，这些文档会指导后面的整个研发流程</li>\n<li>开发阶段的产出物是满足需求的源代码、开发文档，以及编译后的归档文件</li>\n<li>测试阶段的产出物是满足产品需求、达到发布条件的源代码，以及编译后的归档文件</li>\n<li>发布阶段的产出物是正式上线的软件</li>\n<li>运营阶段的产出就是实质上软件运行带来的效益</li>\n</ul>\n<ol start=\"7\">\n<li>\n<p>在项目开发中，你要思考怎么尽可能自动生成代码</p>\n</li>\n<li>\n<p>怎么提高开发效率呢</p>\n</li>\n</ol>\n<ul>\n<li>将开发阶段的步骤通过 Makefile 实现集中管理</li>\n<li>将构建阶段的步骤通过 CI/CD 平台实现自动化</li>\n</ul>\n<ol start=\"9\">\n<li>\n<p>测试工程师根据需求文档创建测试计划、编写测试用例，并拉研发同学一起评审测试计划和用例。评审通过后，测试工程师就会根据测试计划和测试用例对服务进行测试。</p>\n</li>\n<li>\n<p>测试用例几乎不可能涵盖整个变更分支，所以对于一些难测，隐藏的测试，需要研发人员自己加强测试</p>\n</li>\n<li>\n<p>在创建发布计划时，一定要全面梳理这次变更的影响点</p>\n</li>\n<li>\n<p>编写一些自动化的测试用例，在服务发布到现网之后，对现网服务做一次比较充分的回归测试</p>\n</li>\n<li>\n<p>项目中各个角色<br>\n<img src=\"../images/store/dX1R3Y.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>采用一些好的工具或方法在应用的整个生命周期中对应用进行管理，以提高应用的研发效率和质量</p>\n</li>\n<li>\n<p>两个维度来理解应用生命周期管理技术</p>\n</li>\n</ol>\n<ul>\n<li>演进维度，应用生命周期，最开始主要是通过研发模式来管理的，按时间线先后出现了瀑布模式、迭代模式、敏捷模式，为了解决研发模式中的一些痛点，出现了CI/CD，随着CI/CD成熟，就诞生了DevOps</li>\n<li>管理技术的类别</li>\n<li>研发模式，用来确保整个研发流程是高效的</li>\n<li>DevOps，主要通过协调各部门之间的合作，来提高软件的发布效率和质量</li>\n<li>DevOps中又包含很多种技术，主要是CI/CD和多种Ops</li>\n<li>CI/CD提高了软件的发布效率和质量，Ops则提高了软件的运维和运营效率</li>\n</ul>\n<ol start=\"16\">\n<li>\n<p>DevOps 技术里的 CI/CD 专注于流程，Ops 则专注于实战<br>\n<img src=\"../images/store/4l44Mr.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>研发模式建议选择敏捷模式，因为它更能胜任互联网时代快速迭代的诉求</p>\n</li>\n<li>\n<p>DevOps 则要优先确保落地 CI/CD 技术，接着尝试落地 ChatOps 技术，如果有条件可以积极探索 AIOps 和 GitOps</p>\n</li>\n<li>\n<p>瀑布模式</p>\n</li>\n</ol>\n<ul>\n<li>布模式按照预先规划好的研发阶段来推进研发进度</li>\n<li>按照需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段的顺序串行执行开发任务</li>\n<li>每个阶段完美完成之后，才会进入到下一阶段，阶段之间通过文档进行交付<br>\n<img src=\"../images/store/w1gbex.png\" alt=\"\" loading=\"lazy\"></li>\n<li>优点就是简单，严格按照研发阶段推进研发进度，流程清晰，适合按项目交付的应用</li>\n<li>缺点就是只有在研发最后的阶段才会交付给客户，交付后，对于软件的变更会非常困难，代价很大</li>\n<li>研发周期长，不适合现代互联网快速迭代的需求</li>\n</ul>\n<ol start=\"20\">\n<li>迭代模式</li>\n</ol>\n<ul>\n<li>研发任务被切分为一系列轮次，每一个轮次都是一个迭代，每一次迭代都是一个从设计到实现的完整过程</li>\n<li>不要求每一个阶段的任务都做到最完美，而是先把主要功能搭建起来，然后再通过客户的反馈信息不断完善</li>\n<li>迭代模式的问题在于比较专注于开发过程，很少从项目管理的视角去加速和优化项目开发过程</li>\n</ul>\n<ol start=\"21\">\n<li>敏捷模式</li>\n</ol>\n<ul>\n<li>敏捷模式把一个大的需求分成多个、可分阶段完成的小迭代，每个迭代交付的都是一个可使用的软件</li>\n<li>在开发过程中，软件要一直处于可使用状态</li>\n<li>敏捷模式中具有代表性的开发模式，是 Scrum 开发模型</li>\n<li>敏捷模式中，会有很多开发、构建、测试、发布和部署的流程循环，这个给开发、运维和测试带来很大工作量，于是为了解决这个问题，CI/CD诞生了</li>\n</ul>\n<ol start=\"22\">\n<li>CI/CD自动化构建和部署应用</li>\n</ol>\n<ul>\n<li>3个概念</li>\n<li>CI：Continuous Integration，持续集成 -&gt; 频繁地（一天多次）将开发者的代码合并到主干上</li>\n<li>CD：Continuous Delivery，持续交付 -&gt; 持续交付在持续集成的基础上，将构建后的产物自动部署在目标环境中</li>\n<li>CD：Continuous Deployment，持续部署 -&gt; 持续部署在持续交付的基础上，将经过充分测试的代码自动部署到生产环境，整个流程不再需要相关人员的审核</li>\n<li>持续集成的核心点在代码，持续交付的核心点在可交付的产物，持续部署的核心点在自动部署<br>\n<img src=\"../images/store/dg0bfC.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<ol start=\"23\">\n<li>\n<p>DevOps（Development 和 Operations 的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序 / 软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合<br>\n<img src=\"../images/store/BDIx7e.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>DevOps 中的四个 Ops 手段：AIOps、ChatOps、GitOps、NoOps</p>\n</li>\n<li>\n<p>AIOps：智能运维</p>\n</li>\n</ol>\n<ul>\n<li>2016 年，Gartner 提出利用 AI 技术的新一代 IT 运维，即 AIOps（智能运维）</li>\n</ul>\n<ol start=\"26\">\n<li>ChatOps：聊着天就把事情给办了</li>\n</ol>\n<ul>\n<li>简单来说，ChatOps 就是在一个聊天工具中，发送一条命令给 ChatBot 机器人，然后 ChatBot 会执行预定义的操作</li>\n</ul>\n<ol start=\"27\">\n<li>GitOps： 一种实现云原生的持续交付模型</li>\n</ol>\n<ul>\n<li>核心思想是将应用系统的声明性基础架构（YAML）和应用程序存放在 Git 版本库中。将 Git 作为交付流水线的核心，每个开发人员都可以提交拉取请求（Pull Request），并使用 Git 来加速和简化 Kubernetes 的应用程序部署和运维任务<br>\n<img src=\"../images/store/G08FeU.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<ol start=\"28\">\n<li>GitOps 的工作流程</li>\n</ol>\n<ul>\n<li>开发人员开发完代码后推送到 Git 仓库，触发 CI 流程，CI 流程通过编译构建出 Docker 镜像，并将镜像 push 到 Docker 镜像仓库中</li>\n<li>Push 动作会触发一个 push 事件，通过 webhook 的形式通知到 Config Updater 服务，Config Updater 服务会从 webhook 请求中获取最新 push 的镜像名，并更新 Git 仓库中的 Kubernetes YAML 文件</li>\n<li>GitOps 的 Deploy Operator 服务，检测到 YAML 文件的变动，会重新从 Git 仓库中提取变更的文件，并将镜像部署到 Kubernetes 集群中</li>\n</ul>\n<ol start=\"29\">\n<li>NoOps：无运维</li>\n</ol>\n<ul>\n<li>在 NoOps 中不再需要开发人员、运营运维人员的协同，把微服务、低代码、无服务全都结合了起来，开发者在软件生命周期中只需要聚焦业务开发即可，所有的维护都交由云厂商来完成</li>\n<li>NoOps 是运维的终极形态，在我看来它像 DevOps 一样，更多的是一种理念，需要很多的技术和手段来支撑</li>\n</ul>\n<ol start=\"30\">\n<li>如何选择合适的应用生命周期管理技术？</li>\n</ol>\n<ul>\n<li>根据团队、项目选择一个合适的研发模式</li>\n<li>要建立自己的 CI/CD 流程</li>\n<li>除了建立 CI/CD 系统，我还建议将 ChatOps 带入工作中，尽可能地将可以自动化的工作实现自动化，并通过 ChatOps 来触发自动化流程</li>\n<li>GitOps、AIOps 可以将部署和运维自动化做到极致，在团队有人力的情况下，值得探索</li>\n</ul>\n","next":{"title":"【Go语言项目开发】07 工作流设计","link":"2021/07/26/2021-07-26-1"},"plink":"https://terence.segofun.com/2021/07/28/2021-07-28/","reading_time":"2590 words in 17 min"}