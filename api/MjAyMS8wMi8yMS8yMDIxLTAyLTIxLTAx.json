{"title":"【Go语言核心36讲】29/30. 原子操作","date":"2021-02-21T06:39:10.000Z","date_formatted":{"ll":"Feb 21, 2021","L":"02/21/2021","MM-DD":"02-21"},"link":"2021/02/21/2021-02-21-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.561Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）</p>\n</li>\n<li>\n<p>原子操作 -&gt; 在代码执行层面是不允许上下文进行切换的</p>\n</li>\n<li>\n<p>原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效</p>\n</li>\n<li>\n<p>原子操作可以完全地消除竞态条件，并能够绝对地保证并发安全性。并且，它的执行速度要比其他的同步工具快得多，通常会高出好几个数量级</p>\n</li>\n<li>\n<p>Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代码包sync/atomic中</p>\n</li>\n<li>\n<p>sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？</p>\n</li>\n</ol>\n<ul>\n<li>sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）</li>\n<li>对这些类型中的每一个，sync/atomic包都会有一套函数给予支持。这些数据类型有：int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数</li>\n<li>sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值</li>\n</ul>\n<ol start=\"7\">\n<li>\n<p>传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，atomic.AddInt32函数的第一个参数，对应的一定是那个要被增大的整数</p>\n</li>\n<li>\n<p>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据</p>\n</li>\n<li>\n<p>比较并交换操作与交换操作相比有什么不同？优势在哪里？</p>\n</li>\n</ol>\n<ul>\n<li>比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换</li>\n<li>可以实现自旋锁</li>\n</ul>\n<ol start=\"10\">\n<li>\n<p>自旋锁会更加乐观，认为线程会让期待值出现</p>\n</li>\n<li>\n<p>atomic.Value类型是开箱即用的，我们声明一个该类型的变量（以下简称原子变量）之后就可以直接使用了</p>\n</li>\n</ol>\n<ul>\n<li>它只有两个指针方法：Store和Load</li>\n<li>参数值不能为nil</li>\n<li>参数值的类型不能与首个被存储值的类型不同</li>\n<li>不要对外暴露原子变量、不要传递原子值及其指针值、尽量不要在原子值中存储引用类型的值</li>\n</ul>\n<ol start=\"12\">\n<li>如果要对原子值和互斥锁进行二选一，你认为最重要的三个决策条件应该是什么？</li>\n</ol>\n<ul>\n<li>被保护的数据是什么类型的？是值类型的还是引用类型的？</li>\n<li>操作被保护数据的方式是怎样的？是简单的读和写还是更复杂的操作？</li>\n<li>操作被保护数据的代码是集中的还是分散的？如果是分散的，是否可以变为集中的？</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】31. sync.WaitGroup和sync.Once","link":"2021/02/21/2021-02-21-02"},"next":{"title":"【Go语言核心36讲】27/28. 条件变量sync.Cond","link":"2021/02/20/2021-02-20-03"},"plink":"https://terence.segofun.com/2021/02/21/2021-02-21-01/","reading_time":"911 words in 6 min"}