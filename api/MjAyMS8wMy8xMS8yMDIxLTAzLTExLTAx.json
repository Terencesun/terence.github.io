{"title":"【Go语言核心36讲】42/43. bufio包中的数据类型","date":"2021-03-11T01:24:18.000Z","date_formatted":{"ll":"Mar 11, 2021","L":"03/11/2021","MM-DD":"03-11"},"link":"2021/03/11/2021-03-11-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.564Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>bufio包的主要数据类型</li>\n</ol>\n<ul>\n<li>Reader</li>\n<li>Scanner</li>\n<li>Writer和ReadWriter</li>\n</ul>\n<ol start=\"2\">\n<li>源码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Reader struct &#123;</span><br><span class=\"line\">\tbuf          []byte  &#x2F;&#x2F; 具体存buf数据的地方</span><br><span class=\"line\">\trd           io.Reader &#x2F;&#x2F; io读的接口，就是未来实现读的地方</span><br><span class=\"line\">\tr, w         int       &#x2F;&#x2F; r是已读计数，w是已写计数</span><br><span class=\"line\">\terr          error  &#x2F;&#x2F; 错误，有一个方法是readErr()，每次调用后，err会被置nil</span><br><span class=\"line\">\tlastByte     int &#x2F;&#x2F; 记录buf中最后一个被读取的字节，-1的时候表示无效</span><br><span class=\"line\">\tlastRuneSize int &#x2F;&#x2F; 记录buf中最后一个被读取的unicode字符，-1的时候表示无效</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 这是bufio的Reader结构体</span><br><span class=\"line\">&#x2F;&#x2F; Reader的初始化</span><br><span class=\"line\">&#x2F;&#x2F; 有两种，NewReaderSize和NewReader，前者是可以自定义长度的，后者是有一个默认长度的,4029byte，也就是4kb</span><br><span class=\"line\">func NewReaderSize(rd io.Reader, size int) *Reader &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 断言，如果rd本身就是个Reader，那就不用new了，直接返回</span><br><span class=\"line\">\tb, ok :&#x3D; rd.(*Reader)</span><br><span class=\"line\">\tif ok &amp;&amp; len(b.buf) &gt;&#x3D; size &#123;</span><br><span class=\"line\">\t\treturn b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果size小于系统最小的size，那么就设置为最小</span><br><span class=\"line\">\tif size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize &#x3D; minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr :&#x3D; new(Reader)</span><br><span class=\"line\">\t&#x2F;&#x2F; new完Reader后，重置这个reader</span><br><span class=\"line\">\tr.reset(make([]byte, size), rd)</span><br><span class=\"line\">\treturn r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func NewReader(rd io.Reader) *Reader &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 根据默认长度new一个reader就好了</span><br><span class=\"line\">\treturn NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 接下来是一个Peek方法，用于读取指定长度的buf，读取完毕后buf的已读和未读计数会改变</span><br><span class=\"line\">func (b *Reader) Peek(n int) ([]byte, error) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果传入一个小于0的，自然不符合</span><br><span class=\"line\">\tif n &lt; 0 &#123;</span><br><span class=\"line\">\t\treturn nil, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte &#x3D; -1</span><br><span class=\"line\">\tb.lastRuneSize &#x3D; -1</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; b.w-b.r 表示未读的byte长度</span><br><span class=\"line\">    &#x2F;&#x2F; b.w-b.r &lt; n，表示未读的byte长度小于需要读的长度n</span><br><span class=\"line\">    &#x2F;&#x2F; b.w-b.r &lt; len(b.buf)，表示未读的byte长度小于buf数组的长度，理解为buf缓冲区不是满的</span><br><span class=\"line\">    &#x2F;&#x2F; b.err，就表示没有错误咯</span><br><span class=\"line\">    &#x2F;&#x2F; 三个条件下来就是</span><br><span class=\"line\">    &#x2F;&#x2F; 如果未读区域长度小于n</span><br><span class=\"line\">    &#x2F;&#x2F; 如果未读区域的长度小于总buf长度</span><br><span class=\"line\">    &#x2F;&#x2F; 如果没有错误</span><br><span class=\"line\">    &#x2F;&#x2F; 执行fill -&gt; 把未读区域移动到头部</span><br><span class=\"line\">\tfor b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; len(b.buf) &amp;&amp; b.err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tb.fill() &#x2F;&#x2F; b.w-b.r &lt; len(b.buf) &#x3D;&gt; buffer is not full</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 如果给出的n大于buf本身的长度，那么直接把未读部分返回</span><br><span class=\"line\">    &#x2F;&#x2F; 也会同时返回一个错误(个人觉得不像一个错误)</span><br><span class=\"line\">\tif n &gt; len(b.buf) &#123;</span><br><span class=\"line\">\t\treturn b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 0 &lt;&#x3D; n &lt;&#x3D; len(b.buf)</span><br><span class=\"line\">\tvar err error</span><br><span class=\"line\">\tif avail :&#x3D; b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; not enough data in buffer</span><br><span class=\"line\">\t\tn &#x3D; avail</span><br><span class=\"line\">\t\terr &#x3D; b.readErr()</span><br><span class=\"line\">\t\tif err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\terr &#x3D; ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (b *Reader) fill() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 这一步是整理，已读区域移动到头部(如果r&gt;0的话)</span><br><span class=\"line\">\tif b.r &gt; 0 &#123;</span><br><span class=\"line\">\t\tcopy(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -&#x3D; b.r</span><br><span class=\"line\">\t\tb.r &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif b.w &gt;&#x3D; len(b.buf) &#123;</span><br><span class=\"line\">\t\tpanic(&quot;bufio: tried to fill full buffer&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 这里尝试去读取数据(通过io.Read)</span><br><span class=\"line\">\t&#x2F;&#x2F; 尝试次数为100次(maxConsecutiveEmptyReads的值)</span><br><span class=\"line\">\t&#x2F;&#x2F; 读一次就往b.buf存，把b.buf存满</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果读到了，那么就返回了</span><br><span class=\"line\">\t&#x2F;&#x2F; 注意，b.rd.Read这个读取是读取数据源的</span><br><span class=\"line\">\t&#x2F;&#x2F; 数据源的数据长度不一定是不变的，比如流式读取</span><br><span class=\"line\">\t&#x2F;&#x2F; 假设n读出来是0，证明没有数据</span><br><span class=\"line\">\t&#x2F;&#x2F; 就会有ErrNoProgress错误</span><br><span class=\"line\">\t&#x2F;&#x2F; 传递到外层，比如Peek中，就会返回这个错误和一个空切片</span><br><span class=\"line\">\tfor i :&#x3D; maxConsecutiveEmptyReads; i &gt; 0; i-- &#123;</span><br><span class=\"line\">\t\tn, err :&#x3D; b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\tif n &lt; 0 &#123;</span><br><span class=\"line\">\t\t\tpanic(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w +&#x3D; n</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tb.err &#x3D; err</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif n &gt; 0 &#123;</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err &#x3D; io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Reader中的Read</span><br><span class=\"line\">&#x2F;&#x2F; read和peek类型</span><br><span class=\"line\">&#x2F;&#x2F; read会更新已读计数，peek不会</span><br><span class=\"line\">&#x2F;&#x2F; 如果read的参数长度大于buf自身的长度，那么会直接读底层io.read</span><br><span class=\"line\">func (b *Reader) Read(p []byte) (n int, err error) &#123;</span><br><span class=\"line\">\tn &#x3D; len(p)</span><br><span class=\"line\">\tif n &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\tif b.Buffered() &gt; 0 &#123;</span><br><span class=\"line\">\t\t\treturn 0, nil</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn 0, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif b.r &#x3D;&#x3D; b.w &#123;</span><br><span class=\"line\">\t\tif b.err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn 0, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果read的参数长度大于buf自身的长度，那么会直接读底层io.read</span><br><span class=\"line\">\t\tif len(p) &gt;&#x3D; len(b.buf) &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Large read, empty buffer.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Read directly into p to avoid copy.</span><br><span class=\"line\">\t\t\tn, b.err &#x3D; b.rd.Read(p)</span><br><span class=\"line\">\t\t\tif n &lt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tpanic(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif n &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte &#x3D; int(p[n-1])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize &#x3D; -1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; One read.</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Do not use b.fill, which will loop.</span><br><span class=\"line\">\t\tb.r &#x3D; 0</span><br><span class=\"line\">\t\tb.w &#x3D; 0</span><br><span class=\"line\">\t\tn, b.err &#x3D; b.rd.Read(b.buf)</span><br><span class=\"line\">\t\tif n &lt; 0 &#123;</span><br><span class=\"line\">\t\t\tpanic(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif n &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\treturn 0, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w +&#x3D; n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; copy as much as we can</span><br><span class=\"line\">\tn &#x3D; copy(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r +&#x3D; n</span><br><span class=\"line\">\tb.lastByte &#x3D; int(b.buf[b.r-1])</span><br><span class=\"line\">\tb.lastRuneSize &#x3D; -1</span><br><span class=\"line\">\treturn n, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>此外还有ReadSlice和ReadBytes</li>\n</ol>\n<ul>\n<li>ReadSlice方法会在缓冲区的未读部分中寻找给定的分隔符，并在必要时对缓冲区进行填充</li>\n<li>ReadBytes方法会通过调用ReadSlice方法，一次又一次地填充缓冲区，并在其中寻找分隔符。除非发生了未预料到的错误或者找到了分隔符，否则这一过程将会一直进行下去</li>\n</ul>\n<ol start=\"4\">\n<li>\n<p>Reader值的Peek方法、ReadSlice方法和ReadLine方法都可能会造成其缓冲区中的内容的泄露，因为会返回底层数组的切片</p>\n</li>\n<li>\n<p>bufio.Writer类型。把该类值的缓冲区中暂存的数据写进其底层写入器的功能，主要是由它的Flush方法实现的</p>\n</li>\n<li>\n<p>一般情况下，这些写入方法都会先把数据写进其所属值的缓冲区，然后再增加该值中的已写计数。但是，在有些时候，Write方法和ReadFrom方法也会跨过缓冲区，并直接把数据写进其底层写入器</p>\n</li>\n<li>\n<p>虽然这些写入方法都会不时地调用Flush方法，但是在写入所有的数据之后再显式地调用一下这个方法总是最稳妥的</p>\n</li>\n<li>\n<p>ReadSlice和ReadBytes源码阅读</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (b *Reader) ReadSlice(delim byte) (line []byte, err error) &#123;</span><br><span class=\"line\">\ts :&#x3D; 0  &#x2F;&#x2F; 初始化byte数组的查找位置为0</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 查找buffer</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 查找分隔符在byte数组中的索引(在未读区域内)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果大于等于0就是找到了，反之未找到</span><br><span class=\"line\">\t\tif i :&#x3D; bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 更新i的值为i+s，这样就定位到了分隔符那个位置上</span><br><span class=\"line\">\t\t\ti +&#x3D; s</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 切片操作，拿到包含分隔符在内的全部byte数组</span><br><span class=\"line\">\t\t\tline &#x3D; b.buf[b.r : b.r+i+1]</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 更新已读计数</span><br><span class=\"line\">\t\t\tb.r +&#x3D; i + 1</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果存在错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 就把未读区域返回，同时带上err</span><br><span class=\"line\">\t\tif b.err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tline &#x3D; b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r &#x3D; b.w</span><br><span class=\"line\">\t\t\terr &#x3D; b.readErr()</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果b.buf满了</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 就把整个b.buf返回了，带着err</span><br><span class=\"line\">\t\tif b.Buffered() &gt;&#x3D; len(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r &#x3D; b.w</span><br><span class=\"line\">\t\t\tline &#x3D; b.buf</span><br><span class=\"line\">\t\t\terr &#x3D; ErrBufferFull</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; 如果未找到，并且上面一系列操作都没抓到</span><br><span class=\"line\">        &#x2F;&#x2F; s的查找起点的位置更新为未读区域最开始</span><br><span class=\"line\">        &#x2F;&#x2F; 从而不用再次读取之前的</span><br><span class=\"line\">\t\ts &#x3D; b.w - b.r</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; 填补b.buf</span><br><span class=\"line\">\t\tb.fill() &#x2F;&#x2F; buffer is not full</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 注意，这里更新了s，b.fill()之后可能会使得b.buf满掉</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果b.buf满了，就会line&#x3D;b.buf，err&#x3D;errbuffull</span><br><span class=\"line\">\t\t&#x2F;&#x2F; b.fill()执行的时候，如果满了，肯定是是从b.r&#x3D;0开始到末尾的</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果b.buf未满，那么，for循环到下一次，注意这个时候s的值是未读区域的长度</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果这个时候找到了分隔符，就会从b.buf的s+1位置处开始到r.w，这一区域查找分隔符</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这个时候查找出来的分隔符位置i是相对于(s, r.w]的，那么就需要更新i的值，加上个s就好了</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这样做切片的时候，只需要切[b.r, b.r+s+1]就好了</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 由于b.fill()执行的时候，很容易让b.buf满掉</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 也就是说ReadSlice方法很容易返回整个b.buf和一个err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 补充一下lastByte和lastRuneSize字段</span><br><span class=\"line\">\tif i :&#x3D; len(line) - 1; i &gt;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\tb.lastByte &#x3D; int(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize &#x3D; -1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; ReadBytes</span><br><span class=\"line\"></span><br><span class=\"line\">func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error) &#123;</span><br><span class=\"line\">\tvar frag []byte</span><br><span class=\"line\">\t&#x2F;&#x2F; 循环找分隔符</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tvar e error</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这里调用了ReadSlice</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 由于ReadSlice很容易full，然后报一个full的错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; collectFragments调用ReadSlice的时候</span><br><span class=\"line\">\t\tfrag, e &#x3D; b.ReadSlice(delim)</span><br><span class=\"line\">\t\tif e &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; got final fragment</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 忽略了full错误，也就是可劲找这个分隔符，除非有其他错误出现</span><br><span class=\"line\">\t\tif e !&#x3D; ErrBufferFull &#123; &#x2F;&#x2F; unexpected error</span><br><span class=\"line\">\t\t\terr &#x3D; e</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; 复制了一个frag，内容隔离了</span><br><span class=\"line\">\t\tbuf :&#x3D; make([]byte, len(frag))</span><br><span class=\"line\">\t\tcopy(buf, frag)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这里fullBuffers是一个二维数组</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 因为每次都可能搞出来一个frag出来，因为fill()导致的，每次都是full的buf出来，这样就需要记录了</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这个时候，每个都存一个到fullBuffers里面，最终呈现出来的就是，一段一段的buf</span><br><span class=\"line\">\t\tfullBuffers &#x3D; append(fullBuffers, buf)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 总长度就不说啥了</span><br><span class=\"line\">\t\ttotalLen +&#x3D; len(buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 因为最后一个frag找到后，也就是分隔符找到了，fullBuffers没有记录最后一个frag，所以这里要处理一下</span><br><span class=\"line\">\ttotalLen +&#x3D; len(frag)</span><br><span class=\"line\">\treturn fullBuffers, frag, totalLen, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (b *Reader) ReadBytes(delim byte) ([]byte, error) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 首先执行下collectFragments</span><br><span class=\"line\">    &#x2F;&#x2F; 获得了最后一个切片之前的全部full和最后一个切片frag，总长度，和err</span><br><span class=\"line\">\tfull, frag, n, err :&#x3D; b.collectFragments(delim)</span><br><span class=\"line\">\tbuf :&#x3D; make([]byte, n)</span><br><span class=\"line\">\tn &#x3D; 0</span><br><span class=\"line\">\t&#x2F;&#x2F; Copy full pieces and fragment in.</span><br><span class=\"line\">\tfor i :&#x3D; range full &#123;</span><br><span class=\"line\">\t    &#x2F;&#x2F; 分段拼接</span><br><span class=\"line\">\t\tn +&#x3D; copy(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 把最后一个frag拼接上</span><br><span class=\"line\">\tcopy(buf[n:], frag)</span><br><span class=\"line\">\t&#x2F;&#x2F; 完成</span><br><span class=\"line\">\t&#x2F;&#x2F; 这个过程反映了，ReadBytes其必须要找到这个分隔符，找不到比如出现EOF错误，就把全部返出来，带上错误</span><br><span class=\"line\">\treturn buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","prev":{"title":"【Go语言核心36讲】44/45. 使用os包中的API","link":"2021/03/12/2021-03-12-01"},"next":{"title":"【Go语言核心36讲】40/41. io包中的接口和工具","link":"2021/03/08/2021-03-08-01"},"plink":"https://terence.segofun.com/2021/03/11/2021-03-11-01/","reading_time":"2663 words in 18 min"}