{"title":"【Go语言核心36讲】21/22. panic函数、recover函数以及defer语句","date":"2021-02-18T14:08:06.000Z","date_formatted":{"ll":"Feb 18, 2021","L":"02/18/2021","MM-DD":"02-18"},"link":"2021/02/18/2021-02-18-04","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-22T01:02:42.951Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>一个panic错误</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic: runtime error: index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">goroutine 1 [running]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\"> &#x2F;Users&#x2F;haolin&#x2F;GeekTime&#x2F;Golang_Puzzlers&#x2F;src&#x2F;puzzlers&#x2F;article19&#x2F;q0&#x2F;demo47.go:5 +0x3d</span><br><span class=\"line\">exit status 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从 panic 被引发到程序终止运行的大致过程是什么？</li>\n</ul>\n<p>某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级</p>\n<p>这个过程一直扩散到最外层的main，程序就开崩溃并终止运行，panic的详情页完善了，打印出来</p>\n<p><img src=\"../images/store/reltk3.png\" alt=\"\" class=\"φbs\"></p>\n<ol start=\"2\">\n<li>怎样让 panic 包含一个值，以及应该让它包含什么样的值？</li>\n</ol>\n<ul>\n<li>最好传入error类型的错误值，或者其他的可以被有效序列化的值</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>Go 语言的内建函数recover专用于恢复 panic，或者说平息运行时恐慌。recover函数无需任何参数，并且会返回一个空接口类型的值</p>\n</li>\n<li>\n<p>defer语句就是被用来延迟执行代码的。延迟到什么时候呢？这要延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么</p>\n</li>\n<li>\n<p>一个defer语句总是由一个defer关键字和一个调用表达式组成，这里存在一些限制，有一些调用表达式是不能出现在这里的，包括：针对 Go 语言内建函数的调用表达式，以及针对unsafe包中的函数的调用表达式</p>\n</li>\n<li>\n<p>如果一个函数中有多条defer语句，那么那几个defer函数调用的执行顺序是怎样的？</p>\n</li>\n</ol>\n<ul>\n<li>如果只用一句话回答的话，那就是：在同一个函数中，defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反</li>\n<li>defer按照顺序压入栈，函数上下文执行完毕后，按照先进后出(FILO)出栈，这就是执行顺序，这里的栈是用链表实现的</li>\n</ul>\n<ol start=\"7\">\n<li>如果defer中引发panic，会是怎样的执行？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func pi()  &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;进入第二个defer&quot;)</span><br><span class=\"line\">\t\tif res :&#x3D; recover(); res !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;panic: %s\\n&quot;, res)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;进入第一个defer&quot;)</span><br><span class=\"line\">\t\tif res :&#x3D; recover(); res !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;panic: %s\\n&quot;, res)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpanic(&quot;test2 ---&gt;&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(&quot;进入pi&quot;);</span><br><span class=\"line\">\ttime.Sleep(time.Second * 1)</span><br><span class=\"line\">\tpanic(&quot;test1 ---&gt;&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 进入pi</span><br><span class=\"line\">&#x2F;&#x2F; 进入第一个defer</span><br><span class=\"line\">&#x2F;&#x2F; panic: test1 ---&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 进入第二个defer</span><br><span class=\"line\">&#x2F;&#x2F; panic: test2 ---&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">func pi() &#123;</span><br><span class=\"line\">defer func() &#123;</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;进入第二个defer&quot;)</span><br><span class=\"line\">\t\t\tif res :&#x3D; recover(); res !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(&quot;panic: %s\\n&quot;, res)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfmt.Println(&quot;进入第一个defer&quot;)</span><br><span class=\"line\">\t\tif res :&#x3D; recover(); res !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;panic: %s\\n&quot;, res)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpanic(&quot;test2 ---&gt;&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(&quot;进入pi&quot;);</span><br><span class=\"line\">\ttime.Sleep(time.Second * 1)</span><br><span class=\"line\">\tpanic(&quot;test1 ---&gt;&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 进入pi</span><br><span class=\"line\">&#x2F;&#x2F; 进入第一个defer</span><br><span class=\"line\">&#x2F;&#x2F; panic: test1 ---&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 进入第二个defer</span><br><span class=\"line\">&#x2F;&#x2F; panic: test2 ---&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defer中遇到Panic，会被其他defer接住，只要这个defer在同一个栈或同一个作用域中</li>\n<li>比如上面这个可以是并列的defer，也可以在defer中写一个defer</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】23/24. 测试的基本规则和流程","link":"2021/02/19/2021-02-19-01"},"next":{"title":"【Go语言核心36讲】19/20. 错误处理","link":"2021/02/18/2021-02-18-03"},"plink":"https://terence.segofun.com/2021/02/18/2021-02-18-04/"}