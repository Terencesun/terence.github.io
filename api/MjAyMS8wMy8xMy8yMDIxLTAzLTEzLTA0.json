{"title":"【转载】Go 项目实战：实现一个 Redis(3) 之实现内存数据库","date":"2021-03-13T15:15:39.000Z","date_formatted":{"ll":"Mar 13, 2021","L":"03/13/2021","MM-DD":"03-13"},"link":"2021/03/13/2021-03-13-04","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.566Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://mp.weixin.qq.com/s?src=11%C3%97tamp=1615648497&amp;ver=2944&amp;signature=KJOxWs5l0IhTPhEsbi-S8YOPV5ADosbu9y56wc96yxpAGk5zamBkS-AqlIK5Bko2Q7lIhXVWDpU6IxIi8YC7I7ItCOZF*yq53VUIJGgZ0HTyrkbSsDAp7-tF2xguEBzc&amp;new=1\" target=\"_blank\">mp.weixin.qq.com</a></p>\n</blockquote>\n<p>本文是 golang 实现 redis 系列的第三篇, 主要介绍如何实现内存 KV 数据库。本文完整源代码在作者 Github: <a href=\"https://github.com/HDT3213/godis/blob/master/src/db%E3%80%82\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/db。</a></p>\n<p><a href=\"https://github.com/HDT3213/godis/blob/master/src/db/db.go\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/db/db.go</a> 是内存数据库的主要源文件，db.Exec 方法会从协议解析器中获得命令参数并调用相应的处理函数进行处理。</p>\n<h2 id=\"concurrent-hash-map\">Concurrent Hash Map<a title=\"#concurrent-hash-map\" href=\"#concurrent-hash-map\"></a></h2>\n<p>KV 内存数据库的核心是并发安全的哈希表，常见的设计有几种：</p>\n<ul>\n<li>\n<p>sync.map: golang 官方提供的并发哈希表, 性能优秀但结构复杂不便于扩展</p>\n</li>\n<li>\n<p>juc.ConcurrentHashMap: java 的并发哈希表采用分段锁实现。在进行扩容时访问哈希表线程都将协助进行 rehash 操作，在 rehash 结束前所有的读写操作都会阻塞。因为缓存数据库中键值对数量巨大且对读写操作响应时间要求较高，使用 juc 的策略是不合适的。</p>\n</li>\n<li>\n<p>memcached hashtable: 在后台线程进行 rehash 操作时，主线程会判断要访问的哈希槽是否已被 rehash 从而决定操作 old_hashtable 还是操作 primary_hashtable。这种策略使主线程和 rehash 线程之间的竞争限制在哈希槽内，最小化 rehash 操作对读写操作的影响，这是最理想的实现方式。但由于作者才疏学浅无法使用 golang 实现该策略故忍痛放弃（主要原因在于 golang 没有 volatile 关键字, 保证线程可见性的操作非常复杂），欢迎各位读者讨论。</p>\n</li>\n</ul>\n<p>本文采用在 sync.map 发布前 golang 社区广泛使用的分段锁策略。我们将 key 分散到固定数量的 shard 中避免 rehash 操作。shard 是有锁保护的 map, 当 shard 进行 rehash 时会阻塞 shard 内的读写，但不会对其他 shard 造成影响。</p>\n<p>这种策略简单可靠易于实现，但由于需要两次 hash 性能略差。这个 dict 完整源码在 <a href=\"https://github.com/HDT3213/godis/blob/master/src/datastruct/dict/concurrent.go\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/datastruct/dict/concurrent.go</a> 可以独立使用（虽然也没有什么用。。。）。</p>\n<p>定义数据结构:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ConcurrentDict struct &#123;</span><br><span class=\"line\">    table []*Shard</span><br><span class=\"line\">    count int32</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Shard struct &#123;</span><br><span class=\"line\">    m     map[string]interface&#123;&#125;</span><br><span class=\"line\">    mutex sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在构造时初始化 shard，这个操作相对比较耗时:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func computeCapacity(param int) (size int) &#123;</span><br><span class=\"line\"> if param &lt;&#x3D; 16 &#123;</span><br><span class=\"line\">  return 16</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> n :&#x3D; param - 1</span><br><span class=\"line\"> n |&#x3D; n &gt;&gt; 1</span><br><span class=\"line\"> n |&#x3D; n &gt;&gt; 2</span><br><span class=\"line\"> n |&#x3D; n &gt;&gt; 4</span><br><span class=\"line\"> n |&#x3D; n &gt;&gt; 8</span><br><span class=\"line\"> n |&#x3D; n &gt;&gt; 16</span><br><span class=\"line\"> if n &lt; 0 &#123;</span><br><span class=\"line\">  return math.MaxInt32</span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">  return int(n + 1)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func MakeConcurrent(shardCount int) *ConcurrentDict &#123;</span><br><span class=\"line\">    shardCount &#x3D; computeCapacity(shardCount)</span><br><span class=\"line\">    table :&#x3D; make([]*Shard, shardCount)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; shardCount; i++ &#123;</span><br><span class=\"line\">        table[i] &#x3D; &amp;Shard&#123;</span><br><span class=\"line\">            m: make(map[string]interface&#123;&#125;),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d :&#x3D; &amp;ConcurrentDict&#123;</span><br><span class=\"line\">        count: 0,</span><br><span class=\"line\">        table: table,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return d</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>哈希算法选择 FNV 算法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const prime32 &#x3D; uint32(16777619)</span><br><span class=\"line\"></span><br><span class=\"line\">func fnv32(key string) uint32 &#123;</span><br><span class=\"line\">    hash :&#x3D; uint32(2166136261)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; len(key); i++ &#123;</span><br><span class=\"line\">        hash *&#x3D; prime32</span><br><span class=\"line\">        hash ^&#x3D; uint32(key[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return hash</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>定位 shard, 当 n 为 2 的整数幂时 h % n == (n - 1) &amp; h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (dict *ConcurrentDict) spread(hashCode uint32) uint32 &#123;</span><br><span class=\"line\"> if dict &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  panic(&quot;dict is nil&quot;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> tableSize :&#x3D; uint32(len(dict.table))</span><br><span class=\"line\"> return (tableSize - 1) &amp; uint32(hashCode)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (dict *ConcurrentDict) getShard(index uint32) *Shard &#123;</span><br><span class=\"line\"> if dict &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  panic(&quot;dict is nil&quot;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return dict.table[index]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Get 和 Put 方法实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (dict *ConcurrentDict) Get(key string) (val interface&#123;&#125;, exists bool) &#123;</span><br><span class=\"line\"> if dict &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  panic(&quot;dict is nil&quot;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> hashCode :&#x3D; fnv32(key)</span><br><span class=\"line\"> index :&#x3D; dict.spread(hashCode)</span><br><span class=\"line\"> shard :&#x3D; dict.getShard(index)</span><br><span class=\"line\"> shard.mutex.RLock()</span><br><span class=\"line\"> defer shard.mutex.RUnlock()</span><br><span class=\"line\"> val, exists &#x3D; shard.m[key]</span><br><span class=\"line\"> return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (dict *ConcurrentDict) Len() int &#123;</span><br><span class=\"line\"> if dict &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  panic(&quot;dict is nil&quot;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return int(atomic.LoadInt32(&amp;dict.count))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; return the number of new inserted key-value</span><br><span class=\"line\">func (dict *ConcurrentDict) Put(key string, val interface&#123;&#125;) (result int) &#123;</span><br><span class=\"line\"> if dict &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  panic(&quot;dict is nil&quot;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> hashCode :&#x3D; fnv32(key)</span><br><span class=\"line\"> index :&#x3D; dict.spread(hashCode)</span><br><span class=\"line\"> shard :&#x3D; dict.getShard(index)</span><br><span class=\"line\"> shard.mutex.Lock()</span><br><span class=\"line\"> defer shard.mutex.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"> if _, ok :&#x3D; shard.m[key]; ok &#123;</span><br><span class=\"line\">  shard.m[key] &#x3D; val</span><br><span class=\"line\">  return 0</span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">  shard.m[key] &#x3D; val</span><br><span class=\"line\">  dict.addCount()</span><br><span class=\"line\">  return 1</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"lockmap\">LockMap<a title=\"#lockmap\" href=\"#lockmap\"></a></h2>\n<p>上一节实现的 ConcurrentMap 可以保证对单个 key 操作的并发安全性，但是仍然无法满足需求:</p>\n<ol>\n<li>\n<p>MSETNX 命令当且仅当所有给定键都不存在时所有给定键设置值, 因此我们需要锁定所有给定的键直到完成所有键的检查和设置</p>\n</li>\n<li>\n<p>LPOP 命令移除列表中最后一个元素后需要移除该键值对，因此我们锁定该键直到移除元素并移除空列表</p>\n</li>\n</ol>\n<p>因此我们需要实现 db.Locker 用于锁定一个或一组 key 并在我们需要的时候释放锁。</p>\n<p>实现 db.Locker 最直接的想法是使用一个 <code>map[string]*sync.RWMutex</code>, 加锁过程分为两步: 初始化对应的锁 -&gt; 加锁， 解锁过程也分为两步: 解锁 -&gt; 释放对应的锁。那么存在一个无法解决的并发问题:</p>\n<table><thead><tr><th>时间</th><th>协程 A</th><th>协程 B</th></tr></thead><tbody><tr><td>1</td><td><br></td><td>locker[\"a\"].Unlock()</td></tr><tr><td>2</td><td>locker[\"a\"] = &amp;sync.RWMutex{}</td><td><br></td></tr><tr><td>3</td><td><br></td><td>delete(locker[\"a\"])</td></tr><tr><td>4</td><td>locker[\"a\"].Lock()</td><td><br></td></tr></tbody></table>\n<p>由于 t3 时协程 B 释放了锁，t4 时协程 A 试图加锁会失败。</p>\n<p>若我们在解锁时不释放锁就可以避免该异常的发生，但是每个曾经使用过的锁都无法释放从而造成严重的内存泄露。</p>\n<p>我们注意到哈希表的长度远少于可能的键的数量，反过来说多个键可以共用一个哈希槽。若我们不为单个键加锁而是为它所在的哈希槽加锁，因为哈希槽的数量非常少即使不释放锁也不会占用太多内存。</p>\n<p>作者根据这种思想实现了 <a href=\"https://github.com/HDT3213/godis/blob/master/src/datastruct/lock/lock_map.go\" target=\"_blank\">https://github.com/HDT3213/godis/blob/master/src/datastruct/lock/lock_map.go</a> 来解决并发控制问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Locks struct &#123;</span><br><span class=\"line\">    table []*sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Make(tableSize int) *Locks &#123;</span><br><span class=\"line\">    table :&#x3D; make([]*sync.RWMutex, tableSize)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; tableSize; i++ &#123;</span><br><span class=\"line\">        table[i] &#x3D; &amp;sync.RWMutex&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &amp;Locks&#123;</span><br><span class=\"line\">        table: table,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (locks *Locks)Lock(key string) &#123;</span><br><span class=\"line\">    index :&#x3D; locks.spread(fnv32(key))</span><br><span class=\"line\">    mu :&#x3D; locks.table[index]</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (locks *Locks)UnLock(key string) &#123;</span><br><span class=\"line\">    index :&#x3D; locks.spread(fnv32(key))</span><br><span class=\"line\">    mu :&#x3D; locks.table[index]</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>哈希算法已经在 Dict 一节介绍过不再赘述。</p>\n<p>在锁定多个 key 时需要注意，若协程 A 持有键 a 的锁试图获得键 b 的锁，此时协程 B 持有键 b 的锁试图获得键 a 的锁则会形成死锁。</p>\n<p>解决方法是所有协程都按照相同顺序加锁，若两个协程都想获得键 a 和键 b 的锁，那么必须先获取键 a 的锁后获取键 b 的锁，这样就可以避免循环等待。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (locks *Locks) toLockIndices(keys []string, reverse bool) []uint32 &#123;</span><br><span class=\"line\">    indexMap :&#x3D; make(map[uint32]bool)</span><br><span class=\"line\">    for _, key :&#x3D; range keys &#123;</span><br><span class=\"line\">        index :&#x3D; locks.spread(fnv32(key))</span><br><span class=\"line\">        indexMap[index] &#x3D; true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    indices :&#x3D; make([]uint32, 0, len(indexMap))</span><br><span class=\"line\">    for index :&#x3D; range indexMap &#123;</span><br><span class=\"line\">        indices &#x3D; append(indices, index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort.Slice(indices, func(i, j int) bool &#123;</span><br><span class=\"line\">        if !reverse &#123;</span><br><span class=\"line\">            return indices[i] &lt; indices[j]</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return indices[i] &gt; indices[j]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return indices</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (locks *Locks)Locks(keys ...string) &#123;</span><br><span class=\"line\">    indices :&#x3D; locks.toLockIndices(keys, false)</span><br><span class=\"line\">    for _, index :&#x3D; range indices &#123;</span><br><span class=\"line\">        mu :&#x3D; locks.table[index]</span><br><span class=\"line\">        mu.Lock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func (locks *Locks)UnLocks(keys ...string) &#123;</span><br><span class=\"line\">    indices :&#x3D; locks.toLockIndices(keys, true)</span><br><span class=\"line\">    for _, index :&#x3D; range indices &#123;</span><br><span class=\"line\">        mu :&#x3D; locks.table[index]</span><br><span class=\"line\">        mu.Unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"ttl\">TTL<a title=\"#ttl\" href=\"#ttl\"></a></h2>\n<p>Time To Live (TTL) 的实现方式非常简单，其核心是 string -&gt; time 哈希表。</p>\n<p>当访问某个 key 时会检查是否过期，并删除过期 key:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) Get(key string) (*DataEntity, bool) &#123;</span><br><span class=\"line\"> db.stopWorld.RLock()</span><br><span class=\"line\"> defer db.stopWorld.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\"> raw, ok :&#x3D; db.Data.Get(key)</span><br><span class=\"line\"> if !ok &#123;</span><br><span class=\"line\">  return nil, false</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> if db.IsExpired(key) &#123;</span><br><span class=\"line\">  return nil, false</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> entity, _ :&#x3D; raw.(*DataEntity)</span><br><span class=\"line\"> return entity, true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (db *DB) IsExpired(key string) bool &#123;</span><br><span class=\"line\"> rawExpireTime, ok :&#x3D; db.TTLMap.Get(key)</span><br><span class=\"line\"> if !ok &#123;</span><br><span class=\"line\">  return false</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> expireTime, _ :&#x3D; rawExpireTime.(time.Time)</span><br><span class=\"line\"> expired :&#x3D; time.Now().After(expireTime)</span><br><span class=\"line\"> if expired &#123;</span><br><span class=\"line\">  db.Remove(key)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return expired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>同时会定时的检查过期 key 并删除:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) CleanExpired() &#123;</span><br><span class=\"line\"> now :&#x3D; time.Now()</span><br><span class=\"line\"> toRemove :&#x3D; &amp;List.LinkedList&#123;&#125;</span><br><span class=\"line\"> db.TTLMap.ForEach(func(key string, val interface&#123;&#125;) bool &#123;</span><br><span class=\"line\">  expireTime, _ :&#x3D; val.(time.Time)</span><br><span class=\"line\">  if now.After(expireTime) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; expired</span><br><span class=\"line\">   db.Data.Remove(key)</span><br><span class=\"line\">   toRemove.Add(key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return true</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> toRemove.ForEach(func(i int, val interface&#123;&#125;) bool &#123;</span><br><span class=\"line\">  key, _ :&#x3D; val.(string)</span><br><span class=\"line\">  db.TTLMap.Remove(key)</span><br><span class=\"line\">  return true</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (db *DB) TimerTask() &#123;</span><br><span class=\"line\"> ticker :&#x3D; time.NewTicker(db.interval)</span><br><span class=\"line\"> go func() &#123;</span><br><span class=\"line\">  for range ticker.C &#123;</span><br><span class=\"line\">   db.CleanExpired()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作者：finley</p>\n<p>出处：<a href=\"https://www.cnblogs.com/Finley/p/12590718.html\" target=\"_blank\">https://www.cnblogs.com/Finley/p/12590718.html</a></p>\n<p>版权：本作品采用「署名 - 非商业性使用 - 相同方式共享 4.0 国际」许可协议进行许可。</p>\n</blockquote>\n<p><strong>推荐阅读</strong></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651443746&amp;idx=2&amp;sn=b2666d035801106e70be7c28ea1ffd3b&amp;chksm=80bb0cd0b7cc85c6da351cf8973e04686ec7665e54bb9073c7c6be309e4a98d60e49d69c4e1c&amp;scene=21#wechat_redirect\" target=\"_blank\">Go 项目实战：实现一个 Redis(2) 之实现 Redis 协议解析器</a></strong></p>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis(4) 之 AOF 持久化与 AOF 重写","link":"2021/03/14/2021-03-13-05"},"next":{"title":"【转载】Go 项目实战：实现一个 Redis(2) 之实现 Redis 协议解析器","link":"2021/03/13/2021-03-13-03"},"plink":"https://terence.segofun.com/2021/03/13/2021-03-13-04/","toc":[{"id":"concurrent-hash-map","title":"Concurrent Hash Map","index":"1"},{"id":"lockmap","title":"LockMap","index":"2"},{"id":"ttl","title":"TTL","index":"3"}],"reading_time":"2151 words in 14 min"}