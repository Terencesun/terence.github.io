{"title":"【Go语言核心36讲】14. 接口类型的合理运用","date":"2021-02-17T14:57:52.000Z","date_formatted":{"ll":"Feb 17, 2021","L":"02/17/2021","MM-DD":"02-17"},"link":"2021/02/17/2021-02-17-13","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-17T15:39:36.862Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>接口的基础知识</li>\n</ol>\n<ul>\n<li>接口类型与其他数据类型不同，它是没法被实例化的</li>\n<li>既不能通过调用new函数或make函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值</li>\n<li>结构体类型包裹的是它的字段声明，而接口类型包裹的是它的方法定义</li>\n<li>接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征</li>\n<li>对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型</li>\n<li>这种方式还有一个专有名词，叫“Duck typing”，中文常译作“鸭子类型”</li>\n</ul>\n<ol start=\"2\">\n<li>怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？</li>\n</ol>\n<ul>\n<li>一个是“两个方法的签名需要完全一致”，另一个是“两个方法的名称要一模一样”</li>\n</ul>\n<ol start=\"3\">\n<li>概念</li>\n</ol>\n<ul>\n<li>对于一个接口类型的变量来说，例如下面的变量pet，我们赋给它的值可以被叫做它的实际值（也称动态值）</li>\n<li>而该值的类型可以被叫做这个变量的实际类型（也称动态类型）</li>\n<li>比如，我们把取址表达式&amp;dog的结果值赋给了变量pet，这时这个结果值就是变量pet的动态值，而此结果值的类型*Dog就是该变量的动态类型</li>\n<li>动态类型这个叫法是相对于静态类型而言的。对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet，但是它的动态类型却会随着我们赋给它的动态值而变化</li>\n</ul>\n<ol start=\"4\">\n<li>例子说明</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Pet interface &#123;</span><br><span class=\"line\">\tSetName(name string)</span><br><span class=\"line\">\tName() string</span><br><span class=\"line\">\tCategory() string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Dog struct &#123;</span><br><span class=\"line\">\tname string &#x2F;&#x2F; 名字。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (dog *Dog) SetName(name string) &#123;</span><br><span class=\"line\">\tdog.name &#x3D; name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (dog Dog) Name() string &#123;</span><br><span class=\"line\">\treturn dog.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (dog Dog) Category() string &#123;</span><br><span class=\"line\">\treturn &quot;dog&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 示例1。</span><br><span class=\"line\">\tdog :&#x3D; Dog&#123;&quot;little pig&quot;&#125;</span><br><span class=\"line\">\t_, ok :&#x3D; interface&#123;&#125;(dog).(Pet)</span><br><span class=\"line\">\tfmt.Printf(&quot;Dog implements interface Pet: %v\\n&quot;, ok)</span><br><span class=\"line\">\t_, ok &#x3D; interface&#123;&#125;(&amp;dog).(Pet)</span><br><span class=\"line\">\tfmt.Printf(&quot;*Dog implements interface Pet: %v\\n&quot;, ok)</span><br><span class=\"line\">\tfmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 示例2。</span><br><span class=\"line\">\tvar pet Pet &#x3D; &amp;dog</span><br><span class=\"line\">\tfmt.Printf(&quot;This pet is a %s, the name is %q.\\n&quot;,</span><br><span class=\"line\">\t\tpet.Category(), pet.Name())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于一个接口类型的变量来说，例如上面的变量pet，我们赋给它的值可以被叫做它的实际值（也称动态值），而该值的类型可以被叫做这个变量的实际类型（也称动态类型）</li>\n<li>动态类型这个叫法是相对于静态类型而言的。对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet，但是它的动态类型却会随着我们赋给它的动态值而变化</li>\n<li>在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的</li>\n<li>果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本</li>\n<li>当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中，叫做iface，包含两个部分，一个是指向类型信息的指针，一个是指向动态值的指针</li>\n</ul>\n<ol start=\"5\">\n<li>接口变量的值在什么情况下才真正为nil？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dog1 *Dog    &#x2F;&#x2F; dog1是nil，是真的nil</span><br><span class=\"line\">fmt.Println(&quot;The first dog is nil. [wrap1]&quot;)</span><br><span class=\"line\">dog2 :&#x3D; dog1    &#x2F;&#x2F; dog2是nil，是假的nil，这个时候dog2会使用iface，动态值的指针的值是nil，不是真的nil</span><br><span class=\"line\">fmt.Println(&quot;The second dog is nil. [wrap1]&quot;)</span><br><span class=\"line\">var pet Pet &#x3D; dog2  &#x2F;&#x2F; 同理，pet也不是真的nil，这个时候pet !&#x3D; nil，但是打印出来还是nil</span><br><span class=\"line\">if pet &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">  fmt.Println(&quot;The pet is nil. [wrap1]&quot;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  fmt.Println(&quot;The pet is not nil. [wrap1]&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>怎样实现接口之间的组合？</li>\n</ol>\n<ul>\n<li>接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现</li>\n<li>与结构体类型间的嵌入很相似，我们只要把一个接口类型的名称直接写到另一个接口类型的成员列表中就可以了</li>\n</ul>\n<ol start=\"7\">\n<li>总结</li>\n</ol>\n<ul>\n<li>即使我们把一个值为nil的某个实现类型的变量赋给了接口变量，后者的值也不可能是真正的nil。虽然这时它的动态值会为nil，但它的动态类型确是存在的</li>\n<li>除非我们只声明而不初始化，或者显式地赋给它nil，否则接口变量的值就不会为nil</li>\n</ul>\n<ol start=\"8\">\n<li>如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？</li>\n</ol>\n<ul>\n<li>可以的，不过方法内不能使用实现类型内的变量，并且方法接收者必须是指针类型</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】15. 关于指针的有限操作","link":"2021/02/17/2021-02-17-14"},"next":{"title":"【Go语言核心36讲】13. 结构体及其方法的使用法门","link":"2021/02/17/2021-02-17-12"},"plink":"https://terence.segofun.com/2021/02/17/2021-02-17-13/"}