{"title":"【Go语言核心36讲】27/28. 条件变量sync.Cond","date":"2021-02-20T13:12:11.000Z","date_formatted":{"ll":"Feb 20, 2021","L":"02/20/2021","MM-DD":"02-20"},"link":"2021/02/20/2021-02-20-03","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.561Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>什么是条件变量？</li>\n</ol>\n<ul>\n<li>当临界区不满住条件的时候，操作它的县城不用循环做检查，等待通知</li>\n</ul>\n<ol start=\"2\">\n<li>条件变量怎样与互斥锁配合使用？</li>\n</ol>\n<ul>\n<li>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的</li>\n</ul>\n<ol start=\"3\">\n<li>条件变量有三个方法：</li>\n</ol>\n<ul>\n<li>wait 等待通知</li>\n<li>signal 单发通知</li>\n<li>broadcast 广播通知</li>\n</ul>\n<ol start=\"4\">\n<li>对于条件变量的理解</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()  &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; mailbox 信箱</span><br><span class=\"line\">\t&#x2F;&#x2F; 0表示没有情报</span><br><span class=\"line\">\t&#x2F;&#x2F; 1表示有情报</span><br><span class=\"line\">\tvar mailbox uint8</span><br><span class=\"line\">\tvar lock sync.RWMutex</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 基于读写锁的条件变量</span><br><span class=\"line\">\t&#x2F;&#x2F; 条件变量是基于互斥锁的，它必须有互斥锁的支撑才能够起作用</span><br><span class=\"line\">\t&#x2F;&#x2F; sync.Locker是接口，Mutex和RWMutex类型的指针类型才是实现Locker接口的类型</span><br><span class=\"line\">\t&#x2F;&#x2F; sendCond是专门为放置情报而准备的条件变量，向信箱里放置情报，可以被视为对共享资源的写操作</span><br><span class=\"line\">\tsendCond :&#x3D; sync.NewCond(&amp;lock)</span><br><span class=\"line\">\t&#x2F;&#x2F; recvCond变量代表的是专门为获取情报而准备的条件变量</span><br><span class=\"line\">\trecvCond :&#x3D; sync.NewCond(lock.RLocker())</span><br><span class=\"line\"></span><br><span class=\"line\">\tsign :&#x3D; make(chan struct&#123;&#125;, 3)</span><br><span class=\"line\">\tmax :&#x3D; 5</span><br><span class=\"line\"></span><br><span class=\"line\">\tgo func(max int) &#123;</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfor i :&#x3D; 1; i &lt;&#x3D; max; i ++ &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Millisecond * 4000)</span><br><span class=\"line\">\t\t\tlock.Lock()</span><br><span class=\"line\">\t\t\tfor mailbox &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\t\tsendCond.Wait()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;sender [%d]: the mailbox is empty.\\n&quot;, i)</span><br><span class=\"line\">\t\t\tmailbox &#x3D; 1</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;sender [%d]: the letter has been sent.\\n&quot;, i)</span><br><span class=\"line\">\t\t\tlock.Unlock()</span><br><span class=\"line\">\t\t\trecvCond.Signal()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;(max)</span><br><span class=\"line\"></span><br><span class=\"line\">\tgo func(max int) &#123;</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfor j :&#x3D; 1; j &lt;&#x3D; max; j ++ &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Millisecond * 2000)</span><br><span class=\"line\">\t\t\tlock.RLock()</span><br><span class=\"line\">\t\t\tfor mailbox &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;等待收信&quot;)</span><br><span class=\"line\">\t\t\t\trecvCond.Wait()</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;发送者已经响应&quot;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;receiver [%d]: the mailbox is full.\\n&quot;, j)</span><br><span class=\"line\">\t\t\tmailbox &#x3D; 0</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;receiver [%d]: the letter has been received.\\n&quot;, j)</span><br><span class=\"line\">\t\t\tlock.RUnlock()</span><br><span class=\"line\">\t\t\tsendCond.Signal()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;(max)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;- sign</span><br><span class=\"line\">\t&lt;- sign</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>读写锁分开，分别设置读写锁的条件变量</li>\n<li>当我们设定某一个锁为lock状态的时候，可以使用对应的条件变量，让线程在wait()处等待信号过来，注意这个时候，对于对应的锁，会被解锁</li>\n<li>当信号signal()发送的时候，wait()阻塞解除，线程继续往下执行，直到解锁完成</li>\n<li>这种协调机制，其实也可以用channel实现</li>\n</ul>\n<ol start=\"5\">\n<li>wait的机制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 下面的实验说明，在wait的过程中，锁是被释放的</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar sign &#x3D; make(chan struct&#123;&#125;, 3)</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar lock sync.RWMutex</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar lockCond &#x3D; sync.NewCond(&amp;lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 加锁，并等待</span><br><span class=\"line\">\tgo func() &#123;</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfmt.Println(&quot;1 -&gt; 准备加锁&quot;)</span><br><span class=\"line\">\t\tlock.Lock()</span><br><span class=\"line\">\t\tfmt.Println(&quot;1 -&gt; 完成加锁，开始等待&quot;)</span><br><span class=\"line\">\t\tlockCond.Wait()</span><br><span class=\"line\">\t\tfmt.Println(&quot;1 -&gt; 收到信号，等待结束&quot;)</span><br><span class=\"line\">\t\tlock.Unlock()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 不断加锁和解锁，都是读锁</span><br><span class=\"line\">\tgo func() &#123;</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\ttime.Sleep(time.Second * 2)</span><br><span class=\"line\">\t\tfmt.Println(&quot;2 -&gt; 进行加锁&quot;)</span><br><span class=\"line\">\t\tlock.Lock()</span><br><span class=\"line\">\t\tfmt.Println(&quot;2 -&gt; 加锁完成&quot;)</span><br><span class=\"line\">\t\ttime.Sleep(time.Second * 1)</span><br><span class=\"line\">\t\tlock.Unlock()</span><br><span class=\"line\">\t\tfmt.Println(&quot;2 -&gt; 解锁完成&quot;)</span><br><span class=\"line\">\t\tfmt.Println(&quot;2 -&gt; 完成，放出信号&quot;)</span><br><span class=\"line\">\t\tlockCond.Signal()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;- sign</span><br><span class=\"line\">\t&lt;- sign</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当执行到wait的时候，会阻塞，并且会解对应的锁</li>\n<li>当发出signal后，wait会被唤醒，然后重新锁定</li>\n<li>为什么wait之前要先加锁，是因为如果不加锁，那wait会执行解锁，这个时候就会panic</li>\n<li>为什么wait要解锁，因为如果不执行解锁，那么共享数据在的相关临界区，其他线程就会进不来</li>\n<li>为什么wait最好放到for遍历里面？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test3()  &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; mailbox 代表信箱。</span><br><span class=\"line\">\t&#x2F;&#x2F; 0代表信箱是空的，1代表信箱是满的。</span><br><span class=\"line\">\tvar mailbox uint8</span><br><span class=\"line\">\t&#x2F;&#x2F; lock 代表信箱上的锁。</span><br><span class=\"line\">\tvar lock sync.Mutex</span><br><span class=\"line\">\t&#x2F;&#x2F; sendCond 代表专用于发信的条件变量。</span><br><span class=\"line\">\tsendCond :&#x3D; sync.NewCond(&amp;lock)</span><br><span class=\"line\">\t&#x2F;&#x2F; recvCond 代表专用于收信的条件变量。</span><br><span class=\"line\">\trecvCond :&#x3D; sync.NewCond(&amp;lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; send 代表用于发信的函数。</span><br><span class=\"line\">\tsend :&#x3D; func(id, index int) &#123;</span><br><span class=\"line\">\t\tlock.Lock()</span><br><span class=\"line\">\t\tfor mailbox &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\tsendCond.Wait()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Printf(&quot;sender [%d-%d]: the mailbox is empty.&quot;,</span><br><span class=\"line\">\t\t\tid, index)</span><br><span class=\"line\">\t\tmailbox &#x3D; 1</span><br><span class=\"line\">\t\tlog.Printf(&quot;sender [%d-%d]: the letter has been sent.&quot;,</span><br><span class=\"line\">\t\t\tid, index)</span><br><span class=\"line\">\t\tlock.Unlock()</span><br><span class=\"line\">\t\trecvCond.Broadcast()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; recv 代表用于收信的函数。</span><br><span class=\"line\">\trecv :&#x3D; func(id, index int) &#123;</span><br><span class=\"line\">\t\tlock.Lock()</span><br><span class=\"line\">\t\tfor mailbox &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\trecvCond.Wait()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Printf(&quot;receiver [%d-%d]: the mailbox is full.&quot;,</span><br><span class=\"line\">\t\t\tid, index)</span><br><span class=\"line\">\t\tmailbox &#x3D; 0</span><br><span class=\"line\">\t\tlog.Printf(&quot;receiver [%d-%d]: the letter has been received.&quot;,</span><br><span class=\"line\">\t\t\tid, index)</span><br><span class=\"line\">\t\tlock.Unlock()</span><br><span class=\"line\">\t\tsendCond.Signal() &#x2F;&#x2F; 确定只会有一个发信的goroutine。</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; sign 用于传递演示完成的信号。</span><br><span class=\"line\">\tsign :&#x3D; make(chan struct&#123;&#125;, 3)</span><br><span class=\"line\">\tmax :&#x3D; 6</span><br><span class=\"line\">\tgo func(id, max int) &#123; &#x2F;&#x2F; 用于发信。</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfor i :&#x3D; 1; i &lt;&#x3D; max; i++ &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Millisecond * 500)</span><br><span class=\"line\">\t\t\tsend(id, i)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;(0, max)</span><br><span class=\"line\">\tgo func(id, max int) &#123; &#x2F;&#x2F; 用于收信。</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfor j :&#x3D; 1; j &lt;&#x3D; max; j++ &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Millisecond * 200)</span><br><span class=\"line\">\t\t\trecv(id, j)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;(1, max&#x2F;2)</span><br><span class=\"line\">\tgo func(id, max int) &#123; &#x2F;&#x2F; 用于收信。</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tfor k :&#x3D; 1; k &lt;&#x3D; max; k++ &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Millisecond * 200)</span><br><span class=\"line\">\t\t\trecv(id, k)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;(2, max&#x2F;2)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-sign</span><br><span class=\"line\">\t&lt;-sign</span><br><span class=\"line\">\t&lt;-sign</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>– 代码中，如果不放入for里面，那么当通过broadcast通知后，wait唤醒，两个goroutine中肯定有一个的mailbox的值不符合预期，放到for里面可以让不符合预期的goroutine再次进入wait状态</p>\n<ol start=\"6\">\n<li>对于同一个锁，多个 goroutine 对它重复锁定时只会有一个成功，其余的会阻塞；多个 goroutine 对它重复解锁时也只会有一个成功，但其余的会抛 panic</li>\n</ol>\n","prev":{"title":"【Go语言核心36讲】29/30. 原子操作","link":"2021/02/21/2021-02-21-01"},"next":{"title":"【Go语言核心36讲】26. sync.Mutex与sync.RWMutex","link":"2021/02/20/2021-02-20-02"},"plink":"https://terence.segofun.com/2021/02/20/2021-02-20-03/","reading_time":"1449 words in 10 min"}