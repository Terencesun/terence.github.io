{"title":"【转载】Go 项目实战：实现一个 Redis(9) 之 使用 GeoHash 搜索附近的人","date":"2021-03-13T16:31:13.000Z","date_formatted":{"ll":"Mar 14, 2021","L":"03/14/2021","MM-DD":"03-14"},"link":"2021/03/14/2021-03-13-10","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.569Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://www.cnblogs.com/Finley/p/14435424.html\" target=\"_blank\">www.cnblogs.com</a></p>\n</blockquote>\n<p>本文是使用 golang 实现 redis 系列的第九篇，主要介绍如何使用 GeoHash 实现搜索附近的人。</p>\n<p>搜索附近的 POI 是一个非常常见的功能，它的技术难点在于地理位置是二维的 (经纬度) 而我们常用的索引 (无论是 B 树、红黑树还是跳表) 都是一维的。GeoHash 算法的本质就是将二维的经纬度转换为一维的表示。</p>\n<p>本文核心实现代码可以在 <a href=\"https://github.com/HDT3213/godis/tree/master/src/lib/geohash\" target=\"_blank\">Godis:lib/geohash</a> 中找到。也可以下载 <a href=\"https://github.com/HDT3213/godis\" target=\"_blank\">Godis</a> 来亲自体验。</p>\n<blockquote>\n<p>兴趣点 (Point Of Intererst, POI): 在电子地图中我们关心的各种地点被称为 POI, 比如餐厅、超市、写字楼。POI 通常包含名称、经纬度、描述等信息。在搜索附近的人时，你也可以把附近的用户称为 POI。</p>\n</blockquote>\n<h1 id=\"geohash-原理#\">GeoHash 原理<a href=\"#geohash-%E5%8E%9F%E7%90%86\">#</a><a title=\"#geohash-原理#\" href=\"#geohash-原理#\"></a></h1>\n<p>我们知道经度的取值范围是<code>[-180,180]</code>, 纬度取值范围是<code>[-90,90]</code>。我们将经纬度分别二等分，那么可以将地球表面分为 4 个部分:</p>\n<p><img src=\"../images/store/hLwkBC.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>纬度<code>[-90, 0]</code> 用 0 表示，<code>[0, 90]</code>用 1 表示；经度<code>[-180, 0]</code> 用 0 表示，<code>[0, 180]</code>用 1 表示。经度在前纬度在后，这样四个部分都有了一个二进制编码。</p>\n<p>我们对四个小矩形继续二等分:</p>\n<p><img src=\"../images/store/00p0Qm.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>两次等分后的矩形需要用 4bit 来表示。前两位是第一次等分后所在大矩形的编码，后两位表示第二次分割出的小矩形在大矩形中的位置。</p>\n<p>对这些矩形进行进一步分割，分割次数越多矩形越小经度越高，最终我们可以得到最够小的矩形来表示一个点。这个小矩形的编码可以代替这个点的坐标，矩形的边长就是 GeoHash 的误差。</p>\n<p>这种分割方式让我们可以用 Z 型曲线涂满整个地图，这个 Z 型曲线叫做 Peano 空间填充曲线。在大多数情况下空间上相邻的点编码也非常相似。少数情况下编码会发生突变，导致编码相似的点空间距离却很大 (比如上图中的 0111 与 1000)。</p>\n<p><img src=\"../images/store/lIC0Yz.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>如图所示除 Peano 空间填充曲线外还有很多空间填充曲线，其中效果公认较好是 Hilbert 空间填充曲线。相较于 Peano 曲线而言，Hilbert 曲线没有较大的突变。但是由于 Peano 曲线实现更加简单，所以 Geohash 算法采用的是 Peano 空间填充曲线。</p>\n<h1 id=\"实现-geohash-编解码#\">实现 GeoHash 编解码<a href=\"#%E5%AE%9E%E7%8E%B0-geohash-%E7%BC%96%E8%A7%A3%E7%A0%81\">#</a><a title=\"#实现-geohash-编解码#\" href=\"#实现-geohash-编解码#\"></a></h1>\n<p>看过上文的介绍，我们可以很快的写出 GeoHash 的编码过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 返回二进制编码和对应矩形的经纬度范围</span><br><span class=\"line\"></span><br><span class=\"line\">func encode0(latitude, longitude float64, bitSize uint) ([]byte, [2][2]float64) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    box :&#x3D; [2][2]float64&#123; &#x2F;&#x2F; Geohash的矩形</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-180, 180&#125;, &#x2F;&#x2F; 经度</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-90, 90&#125;,   &#x2F;&#x2F; 纬度</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pos :&#x3D; [2]float64&#123;longitude, latitude&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bits :&#x3D; make([]bit, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    var precision uint &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">    for precision &lt; bitSize &#123; &#x2F;&#x2F; 循环直到精度足够</span><br><span class=\"line\"></span><br><span class=\"line\">        for direction, val :&#x3D; range pos &#123; &#x2F;&#x2F; 轮流处理经纬度，p.s. 看到这个循环了吗？你可以很方便的把GeoHash推广到N维空间</span><br><span class=\"line\"></span><br><span class=\"line\">            mid :&#x3D; (box[direction][0] + box[direction][1]) &#x2F; 2 &#x2F;&#x2F; 计算分割点</span><br><span class=\"line\"></span><br><span class=\"line\">            if val &lt; mid &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 经(纬)度小于中点，编码填0，把一下次二分的上界设为当前区间的中点</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][1] &#x3D; mid</span><br><span class=\"line\"></span><br><span class=\"line\">                bits &#x3D; append(bits, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; else &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 经(纬)度大于中点，编码填1，把一下次二分的下界设为当前区间的中点</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][0] &#x3D; mid</span><br><span class=\"line\"></span><br><span class=\"line\">                bits &#x3D; append(bits, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            bit++</span><br><span class=\"line\"></span><br><span class=\"line\">            precision++</span><br><span class=\"line\"></span><br><span class=\"line\">            if precision &#x3D;&#x3D; bitSize &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                break</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return []byte(bits), box</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码非常简单，类似于二分查找。遗憾的是和大多数语言一样 golang 操作二进制数据的最小单位是 byte 而非 bit，所以我们需要额外做一些工作来实现按 bit 编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 这才是真正的实现，请关注与上一节代码的不同</span><br><span class=\"line\"></span><br><span class=\"line\">var bits &#x3D; []uint8&#123;128, 64, 32, 16, 8, 4, 2, 1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func encode0(latitude, longitude float64, bitSize uint) ([]byte, [2][2]float64) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    box :&#x3D; [2][2]float64&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-180, 180&#125;, &#x2F;&#x2F; lng</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-90, 90&#125;,   &#x2F;&#x2F; lat</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pos :&#x3D; [2]float64&#123;longitude, latitude&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hash :&#x3D; &amp;bytes.Buffer&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bit :&#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">    var precision uint &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">    code :&#x3D; uint8(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    for precision &lt; bitSize &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        for direction, val :&#x3D; range pos &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            mid :&#x3D; (box[direction][0] + box[direction][1]) &#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">            if val &lt; mid &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][1] &#x3D; mid </span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 编码默认为0，不需要操作</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][0] &#x3D; mid</span><br><span class=\"line\"></span><br><span class=\"line\">                code |&#x3D; bits[bit]</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 通过位或操作写入1，比如要在字节的第3位写入1应该 code |&#x3D; 32</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            bit++</span><br><span class=\"line\"></span><br><span class=\"line\">            if bit &#x3D;&#x3D; 8 &#123; &#x2F;&#x2F; 计算完一个字节的编码，将其写入buffer</span><br><span class=\"line\"></span><br><span class=\"line\">                hash.WriteByte(code)</span><br><span class=\"line\"></span><br><span class=\"line\">                bit &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">                code &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            precision++</span><br><span class=\"line\"></span><br><span class=\"line\">            if precision &#x3D;&#x3D; bitSize &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                break</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; precision 可能无法被 8 整除，此时剩下的二进制编码写到最后</span><br><span class=\"line\"></span><br><span class=\"line\">    if code &gt; 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        hash.WriteByte(code)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return hash.Bytes(), box</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>为了方便传输 GeoHash 定义了一种文本格式的编码，它是将二进制编码进行 Base32 变换后得到的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; GeoHash的映射表和标准Base32映射表有些不同</span><br><span class=\"line\"></span><br><span class=\"line\">var enc &#x3D; base32.NewEncoding(&quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;).WithPadding(base32.NoPadding)</span><br><span class=\"line\"></span><br><span class=\"line\">func ToString(buf []byte) string &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return enc.EncodeToString(buf)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>写完代码后可以到 <a href=\"http://www.geohash.cn/\" target=\"_blank\">www.geohash.cn</a> 上测试一下结果是否正确。</p>\n<p>跟随二进制编码的指示进行二分既可完成解码的过程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func decode0(hash []byte) [][]float64 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    box :&#x3D; [][]float64&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-180, 180&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;-90, 90&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    direction :&#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; len(hash); i++ &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        code :&#x3D; hash[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        for j :&#x3D; 0; j &lt; len(bits); j++ &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            mid :&#x3D; (box[direction][0] + box[direction][1]) &#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">            mask :&#x3D; bits[j] &#x2F;&#x2F; 使用掩码取出指定位</span><br><span class=\"line\"></span><br><span class=\"line\">            if mask&amp;code &gt; 0 &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 经(纬)度大于mid</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][0] &#x3D; mid</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 经(纬)度小于mid</span><br><span class=\"line\"></span><br><span class=\"line\">                box[direction][1] &#x3D; mid</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            direction &#x3D; (direction + 1) % 2</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return box</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>解码过程不能得到精确的结果只能得到对应矩形的经纬度范围，我们通常使用矩形的中心点来作为编码对应的坐标。</p>\n<h1 id=\"搜索附近#\">搜索附近<a href=\"#%E6%90%9C%E7%B4%A2%E9%99%84%E8%BF%91\">#</a><a title=\"#搜索附近#\" href=\"#搜索附近#\"></a></h1>\n<p>因为位于同一个矩形中的点它们的 GeoHash 编码拥有相同的前缀，所以我们可以非常容易的找到某个矩形中的所有 POI。</p>\n<p>理论上我们在使用 GeoHash 来搜索附近 POI 时只需要找到一个合适的矩形然后找出其中所有 POI 即可，实际上我们面临两个问题:</p>\n<ol>\n<li>即上文提到的 GeoHash 值突变会导致编码相近两个点空间距离很大。</li>\n<li>若我们的位置在矩形的边缘, 那么隔壁矩形里的 POI 可能会更近。</li>\n</ol>\n<p><img src=\"../images/store/k7fOkJ.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>若我们位于红点位置，北面的绿点虽然与我们不在同一个矩形内但显然更近。</p>\n<p>为了解决这些问题，我们除了搜索定位点所在的矩形外，还搜索周围 8 个区域内的 POI。</p>\n<p>这样搜索附近需要分为两步来实现:</p>\n<ol>\n<li>计算所有 POI 的 GeoHash 值，并使用跳表或 B + 树等便于进行范围查询的数据结构建立索引</li>\n<li>计算 “附近区域” 对应的 GeoHash 编码，找出这些区域内的所有 POI</li>\n</ol>\n<h2 id=\"建立空间索引#\">建立空间索引<a href=\"#%E5%BB%BA%E7%AB%8B%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95\">#</a><a title=\"#建立空间索引#\" href=\"#建立空间索引#\"></a></h2>\n<p>我们将 GeoHash 的精度设置为 64 位，这样我们就可以将 GeoHash 编码转换成 uint64 类型存入 SortedSet 数据结构中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ToInt(buf []byte) uint64 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if len(buf) &lt; 8 &#123; &#x2F;&#x2F; 用0填充不足的位数</span><br><span class=\"line\"></span><br><span class=\"line\">        buf2 :&#x3D; make([]byte, 8)</span><br><span class=\"line\"></span><br><span class=\"line\">        copy(buf2, buf)</span><br><span class=\"line\"></span><br><span class=\"line\">        return binary.BigEndian.Uint64(buf2)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return binary.BigEndian.Uint64(buf)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为位于同一矩形的二进制编码拥有相同的前缀所以我们需要将二进制编码的低端作为 uint64 的高位（即使用大端序），这样位于同一矩形的 uint64 编码都会处于同一个数字区间内。比如 0110 矩形内所有点的 uint64 编码都会处于<code>[0x6000000000000000, 0x7000000000000000)</code>区间内, 结合 SortedSet 的范围查询能力我们可以非常迅速地 (时间复杂度 O(logN)) 找到所有位于 0110 区域内的 POI。</p>\n<p>使用 SortedSet 进行索引的代码可以在 <a href=\"https://github.com/HDT3213/godis/blob/master/src/db/geo.go\" target=\"_blank\">Godis:db/geo.go</a> 中找到。</p>\n<h2 id=\"找到附近的区域#\">找到附近的区域<a href=\"#%E6%89%BE%E5%88%B0%E9%99%84%E8%BF%91%E7%9A%84%E5%8C%BA%E5%9F%9F\">#</a><a title=\"#找到附近的区域#\" href=\"#找到附近的区域#\"></a></h2>\n<p>我们知道地球半径约为 6371km 那么第一次分割后我们得到了四个东西宽 6371π km 南北高 3186π km 的矩形，以此递推在分割 10 次后我们可以得到宽约 40km 高约 20km 的矩形。也就是说 20bit 的 GeoHash 编码东西方向上的误差为 40km, 南北方向误差为 20 km。</p>\n<p>我们在 wikipedia 上查到 geohash 的误差范围:</p>\n<p><img src=\"../images/store/K4efwl.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>表格中的 geohash length 是 base32 编码后的字符串长度，1 个字符可以表示 5 位 (bit)。</p>\n<p>我们也可以用代码估算指定的距离需要的 geohash length:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func estimatePrecisionByRadius(radiusMeters float64, latitude float64) uint &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if radiusMeters &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return defaultBitSize - 1</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var precision uint &#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">    for radiusMeters &lt; MercatorMax &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        radiusMeters *&#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">        precision++</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    precision -&#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">    if latitude &gt; 66 || latitude &lt; -66 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        precision--</span><br><span class=\"line\"></span><br><span class=\"line\">        if latitude &gt; 80 || latitude &lt; -80 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            precision--</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if precision &lt; 1 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        precision &#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if precision &gt; 32 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        precision &#x3D; 32</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return precision*2 - 1</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这段代码中需要注意两点:</p>\n<ol>\n<li>因为地球是球型在绘制地图时采用墨卡托投影法 (Mercator Projection) 在靠近南北两极的地方投影面积比较大（在世界地图上靠近北极的格陵兰岛看上去非常大），所以在高纬度区域需要减少精度</li>\n<li>经度的取值范围是<code>[-180,180]</code>纬度的取值范围是<code>[-90,90]</code>, 所以在经纬度等分相同次数后我们得到的矩形总是东西长南北短。为了解决这个问题我们返回的精度总是奇数 (precision*2 - 1), 这样经度比纬度多分割一次就可以得到长宽基本相等的矩形了。</li>\n</ol>\n<p>接下来我们计算矩形区域对应的 uint64 编码的上下界:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ToRange(scope []byte, precision uint) [2]uint64 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    lower :&#x3D; ToInt(scope)</span><br><span class=\"line\"></span><br><span class=\"line\">    radius :&#x3D; uint64(1 &lt;&lt; (64 - precision)) </span><br><span class=\"line\"></span><br><span class=\"line\">    upper :&#x3D; lower + radius</span><br><span class=\"line\"></span><br><span class=\"line\">    return [2]uint64&#123;lower, upper&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>比如位于 0110 矩形内的点它们的 uint64 编码会处于<code>[0110..., 0111...)</code>范围内，在二进制编码中找到合适的位置 + 1 就可以了。</p>\n<p>下一步是计算九宫格的 GeoHash 编码，我们采用了计算各个矩形中心点经纬度然后重新编码的实现方式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func GetNeighbours(latitude, longitude, radiusMeters float64) [][2]uint64 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    precision :&#x3D; estimatePrecisionByRadius(radiusMeters, latitude)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    center, box :&#x3D; encode0(latitude, longitude, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    height :&#x3D; box[0][1] - box[0][0]</span><br><span class=\"line\"></span><br><span class=\"line\">    width :&#x3D; box[1][1] - box[1][0]</span><br><span class=\"line\"></span><br><span class=\"line\">    centerLng :&#x3D; (box[0][1] + box[0][0]) &#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">    centerLat :&#x3D; (box[1][1] + box[1][0]) &#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">    maxLat :&#x3D; ensureValidLat(centerLat + height)</span><br><span class=\"line\"></span><br><span class=\"line\">    minLat :&#x3D; ensureValidLat(centerLat - height)</span><br><span class=\"line\"></span><br><span class=\"line\">    maxLng :&#x3D; ensureValidLng(centerLng + width)</span><br><span class=\"line\"></span><br><span class=\"line\">    minLng :&#x3D; ensureValidLng(centerLng - width)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var result [10][2]uint64</span><br><span class=\"line\"></span><br><span class=\"line\">    leftUpper, _ :&#x3D; encode0(maxLat, minLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[1] &#x3D; ToRange(leftUpper, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    upper, _ :&#x3D; encode0(maxLat, centerLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[2] &#x3D; ToRange(upper, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    rightUpper, _ :&#x3D; encode0(maxLat, maxLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[3] &#x3D; ToRange(rightUpper, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    left, _ :&#x3D; encode0(centerLat, minLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[4] &#x3D; ToRange(left, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[5] &#x3D; ToRange(center, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    right, _ :&#x3D; encode0(centerLat, maxLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[6] &#x3D; ToRange(right, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    leftDown, _ :&#x3D; encode0(minLat, minLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[7] &#x3D; ToRange(leftDown, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    down, _ :&#x3D; encode0(minLat, centerLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[8] &#x3D; ToRange(down, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    rightDown, _ :&#x3D; encode0(minLat, maxLng, precision)</span><br><span class=\"line\"></span><br><span class=\"line\">    result[9] &#x3D; ToRange(rightDown, precision)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    return result[1:]</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>也可以通过某个矩形的编码快速推断出附近 8 个矩形的编码, 这种方式实现难度较高可以参考 Redis 中的实现:</p>\n<ul>\n<li>入口: <a href=\"https://github.com/tracenow/redis-4.0-annotation/blob/master/src/geohash.c#L262\" target=\"_blank\">geohashNeighbors</a></li>\n<li>东西向平移: <a href=\"https://github.com/tracenow/redis-4.0-annotation/blob/master/src/geohash.c#L224\" target=\"_blank\">geohash_move_x</a></li>\n<li>南北向平移: <a href=\"https://github.com/tracenow/redis-4.0-annotation/blob/master/src/geohash.c#L244\" target=\"_blank\">geohash_move_y</a></li>\n</ul>\n<p>最后在 SortedSet 中找到 POI:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func geoRadius0(sortedSet *sortedset.SortedSet, lat float64, lng float64, radius float64) redis.Reply &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    areas :&#x3D; geohash.GetNeighbours(lat, lng, radius)</span><br><span class=\"line\"></span><br><span class=\"line\">    members :&#x3D; make([][]byte, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    for _, area :&#x3D; range areas &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        lower :&#x3D; &amp;sortedset.ScoreBorder&#123;Value: float64(area[0])&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        upper :&#x3D; &amp;sortedset.ScoreBorder&#123;Value: float64(area[1])&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        elements :&#x3D; sortedSet.RangeByScore(lower, upper, 0, -1, true)</span><br><span class=\"line\"></span><br><span class=\"line\">        for _, elem :&#x3D; range elements &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            members &#x3D; append(members, []byte(elem.Member))</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return reply.MakeMultiBulkReply(members)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://github.com/HDT3213/godis/blob/master/src/db/geo.go#L237\" target=\"_blank\">源码传送门</a></p>\n</blockquote>\n<p>OK, 大功告成。</p>\n","prev":{"title":"consul 单机集群搭建","link":"2021/03/16/2021-03-16-01"},"next":{"title":"【转载】Go 项目实战：实现一个 Redis(8) 之 TCC 分布式事务","link":"2021/03/14/2021-03-13-09"},"plink":"https://terence.segofun.com/2021/03/14/2021-03-13-10/","toc":[{"id":"geohash-原理#","title":"GeoHash 原理","index":"1"},{"id":"实现-geohash-编解码#","title":"实现 GeoHash 编解码","index":"2"},{"id":"搜索附近#","title":"搜索附近","index":"3","children":[{"id":"建立空间索引#","title":"建立空间索引","index":"3.1"},{"id":"找到附近的区域#","title":"找到附近的区域","index":"3.2"}]}],"reading_time":"3161 words in 21 min"}