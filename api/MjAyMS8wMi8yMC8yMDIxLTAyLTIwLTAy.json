{"title":"【Go语言核心36讲】26. sync.Mutex与sync.RWMutex","date":"2021-02-20T09:44:52.000Z","date_formatted":{"ll":"Feb 20, 2021","L":"02/20/2021","MM-DD":"02-20"},"link":"2021/02/20/2021-02-20-02","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-22T01:02:42.952Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>线程之间的运行需要共享数据，Go -&gt; 用通讯的方式共享数据</p>\n</li>\n<li>\n<p>数据被多个线程共享，就可能产生争用和冲突的情况，成为竞态条件(race condition)，会破坏共享数据的一致性</p>\n</li>\n<li>\n<p>共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果，一旦一致性约定被破坏，那么线程中的代码和流程的正确性会被影响</p>\n</li>\n<li>\n<p>如果多个线程在争抢一个共享数据，那么为了保护数据的一致性，就需要有一个同步的概念</p>\n</li>\n<li>\n<p>同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块</p>\n</li>\n<li>\n<p>一个线程在想要访问某一个共享资源的时候，需要先申请对该资源的访问权限，并且只有在申请成功之后，访问才能真正开始 -&gt; 这是一种办法，还有其他办法</p>\n</li>\n<li>\n<p>不同进程进入他们自己需要操作共享内存的代码块，这些代码块叫做临界区(critical section)，如果代码块不相同，那么也可以叫做相关临界区</p>\n</li>\n<li>\n<p>为了防止共享数据被破坏，需要施加保护，手段就是通过同步工具进行，go里面常用的是互斥量(mutual exclusion，简称mutex)<br>\n<img src=\"../images/store/AYF3Vs.png\" alt=\"\"></p>\n</li>\n<li>\n<p>一个互斥锁可以被用来保护一个临界区或者一组相关临界区</p>\n</li>\n<li>\n<p>互斥锁有Lock方法和Unlock方法，用来锁定和解锁</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mu.Lock()</span><br><span class=\"line\">_, err :&#x3D; writer.Write([]byte(data))</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\"> log.Printf(&quot;error: %s [%d]&quot;, err, id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mu.Unlock()</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>互斥锁的注意事项：</li>\n</ol>\n<ul>\n<li>不要重复锁定互斥锁；</li>\n<li>不要忘记解锁互斥锁，必要时使用defer语句；</li>\n<li>不要对尚未锁定或者已解锁的互斥锁解锁；</li>\n<li>不要在多个函数之间直接传递互斥锁。</li>\n</ul>\n<ol start=\"12\">\n<li>\n<p>对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上</p>\n</li>\n<li>\n<p>如果一个互斥锁同时用在了多个地方，共享了这个锁，必然会有更多goroutine争抢这个锁，会加大死锁的可能性</p>\n</li>\n<li>\n<p>避免死锁的方法就是每个互斥锁都只保护一个临界区或一组相关临界区</p>\n</li>\n<li>\n<p>一个 goroutine 对某一个互斥锁的重复锁定，就意味着它自己锁死了自己，不要这么做</p>\n</li>\n<li>\n<p>为了避免遗忘解锁或者遇到程序条件分叉导致忘记解锁，最好就是在Lock的下方使用defer进行解锁</p>\n</li>\n<li>\n<p>在锁使用的时候，我们总是应该保证，对于每一个锁定操作，都要有且只有一个对应的解锁操作<br>\n<img src=\"../images/store/4qUbKy.png\" alt=\"\"></p>\n</li>\n<li>\n<p>一旦我们声明了一个sync.Mutex类型的变量，就可以直接使用它了</p>\n</li>\n</ol>\n<ul>\n<li>该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生</li>\n<li>原值和副本都是完全独立的，是不同的互斥锁</li>\n</ul>\n<ol start=\"19\">\n<li>读写锁与互斥锁有哪些异同？</li>\n</ol>\n<ul>\n<li>读写锁 -&gt; sync.RWMutex; 互斥锁 -&gt; sync.Mutex</li>\n<li>读写锁包含两个锁，读锁和写锁; sync.RWMutex类型中的Lock方法和Unlock方法是对写锁的锁定和解锁，RLock和RUnlock是对读锁的锁定和解锁</li>\n<li>写锁Lock, Lock写锁，阻塞</li>\n<li>写锁Lock, RLock读锁，阻塞</li>\n<li>读锁RLock, Lock写锁，阻塞</li>\n<li>读锁RLock, RLock读锁，不阻塞</li>\n<li>对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行</li>\n<li>无论是互斥锁还是读写锁，我们都不要试图去解锁未锁定的锁，因为这样会引发不可恢复的 panic</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】27/28. 条件变量sync.Cond","link":"2021/02/20/2021-02-20-03"},"next":{"title":"【Go语言核心36讲】25. 更多的测试手法","link":"2021/02/20/2021-02-20-01"},"plink":"https://terence.segofun.com/2021/02/20/2021-02-20-02/"}