{"title":"【Go语言核心36讲】31. sync.WaitGroup和sync.Once","date":"2021-02-21T07:36:10.000Z","date_formatted":{"ll":"Feb 21, 2021","L":"02/21/2021","MM-DD":"02-21"},"link":"2021/02/21/2021-02-21-02","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.561Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>如何使用sync.WaitGroup?</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">func test() &#123;</span><br><span class=\"line\">    time.Sleep(time.Second * 1)</span><br><span class=\"line\">    wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    wg.Add(2)</span><br><span class=\"line\">    go test()</span><br><span class=\"line\">    go test()</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>wg中维护了一个计数器，当计数器的值为0的时候，触发wait，唤醒主Goroutine</p>\n</li>\n<li>\n<p>wg的计数器不可以小于0</p>\n</li>\n<li>\n<p>wg.Add的参数可以小于0，但是计数器的值不能小于0</p>\n</li>\n<li>\n<p>wg.Wait不能早于wg.Add使用<br>\n<img src=\"../images/store/MIK-GuxrVQ.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行</p>\n</li>\n<li>\n<p>sync.One的Do方法怎么保证只执行参数函数一次？</p>\n</li>\n</ol>\n<ul>\n<li>sync.Once类型（以下简称Once类型）也属于结构体类型，同样也是开箱即用和并发安全的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Once struct &#123;</span><br><span class=\"line\">    done uint32</span><br><span class=\"line\">    m Mutex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Once的结构体中done字段的值只有0和1，获取和更改这个值是通过原子操作进行的，这就保证了线程安全</li>\n<li>Once的执行流程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 假设两个goroutine同时执行同一个Once.Do(func() &#123;&#125;)</span><br><span class=\"line\">&#x2F;&#x2F; 1. 通过原子操作LoadUint32获取done的值，如果为0，为false，可以进入到下一步，如果为1，不可以进入到下一步</span><br><span class=\"line\">&#x2F;&#x2F; 2. 判断通过后，立刻上锁，调用m.Lock()，进入临界区，这个时候，就算两个goroutine都进来了，其中有一个goroutine必然会阻塞</span><br><span class=\"line\">&#x2F;&#x2F; 3. 获取到锁的goroutine再次判断done的值，如果是false，可以执行func()&#123;&#125;，如果是true，那么立刻解锁</span><br><span class=\"line\">&#x2F;&#x2F; 4. 获取到锁的goroutine，并且判断done的值通过，执行完func() &#123;&#125;之后，原子操作设置done的值为1，然后解锁，注意，这个时候就算那个阻塞的goroutine解锁，由于第三步还有一个判断，导致阻塞的goroutine也不会执行fun() &#123;&#125;，这样就保证了唯一执行</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次判断done值叫做快速失败路径，第二次判断done值叫做常规路径，两次判断叫做跨临界区的双重检查</li>\n<li>注意在第二步的时候，如果临界区的执行时间过长，<a href=\"http://xn--once-uj5fl3an8km54btj5e4or.Do\">那么其他执行once.Do</a>()的goroutine会长时间阻塞，因为这里上了锁m.Lock()</li>\n</ul>\n<ol start=\"8\">\n<li>番外：GoF设计模式 -&gt; 就是我们说的23常用设计模式，GoF是指Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides这四个人的称呼，Gang of Four</li>\n</ol>\n","prev":{"title":"【Go语言核心36讲】32. context.Context类型","link":"2021/02/22/2021-02-22-01"},"next":{"title":"【Go语言核心36讲】29/30. 原子操作","link":"2021/02/21/2021-02-21-01"},"plink":"https://terence.segofun.com/2021/02/21/2021-02-21-02/","reading_time":"691 words in 5 min"}