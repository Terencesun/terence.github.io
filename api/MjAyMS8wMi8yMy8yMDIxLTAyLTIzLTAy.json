{"title":"【Go语言核心36讲】34/35. 并发安全字典sync.Map","date":"2021-02-23T09:47:37.000Z","date_formatted":{"ll":"Feb 23, 2021","L":"02/23/2021","MM-DD":"02-23"},"link":"2021/02/23/2021-02-23-02","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-24T02:06:20.463Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>sync.Map对于键的类型要求和map是一样的，因为sync.Map的底层还是map</p>\n</li>\n<li>\n<p>sync.Map的键的类型不能是函数类型、字典类型和切片类型</p>\n</li>\n<li>\n<p>我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际类型。无论是存、取还是删</p>\n</li>\n<li>\n<p>我们必须保证键的类型是可比较的（或者说可判等的）。如果你实在拿不准，那么可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值（即：reflect.Type类型的值），然后再调用这个值的Comparable方法，得到确切的判断结果</p>\n</li>\n<li>\n<p>因为sync.Map接收的值都是interface{}类型，那么，需要保证键值的类型的正确性</p>\n</li>\n</ol>\n<ul>\n<li>可以使用reflect.TypeOf得到值的类型，然后做断言判断，这个时候传入的值是可以用编译器进行类型检查的</li>\n<li>也可以构造一个结构体，里面可以声明我们需要的类型，比如</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ConcurrentMap struct &#123;</span><br><span class=\"line\"> m         sync.Map</span><br><span class=\"line\"> keyType   reflect.Type</span><br><span class=\"line\"> valueType reflect.Type</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func (cMap *ConcurrentMap) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;</span><br><span class=\"line\"> if reflect.TypeOf(key) !&#x3D; cMap.keyType &#123;</span><br><span class=\"line\">  return</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return cMap.m.Load(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后可以在封装的Load那些函数里面，加上类型判断，不过这种方式编译器是不能帮助我们做类型判断的，这是动态的</li>\n</ul>\n<ol start=\"6\">\n<li>sync.Map源码的实现</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Map struct &#123;</span><br><span class=\"line\">\tmu Mutex</span><br><span class=\"line\">\tread atomic.Value &#x2F;&#x2F; readOnly</span><br><span class=\"line\">\tdirty map[interface&#123;&#125;]*entry</span><br><span class=\"line\">\tmisses int</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th>说明</th>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mu</td>\n<td>Mutex</td>\n<td>加锁作用。保护后文的dirty字段</td>\n</tr>\n<tr>\n<td>read</td>\n<td>atomic.Value</td>\n<td>存读的数据。因为是atomic.Value类型，只读，所以并发是安全的。实际存的是readOnly的数据结构。</td>\n</tr>\n<tr>\n<td>misses</td>\n<td>int</td>\n<td>计数作用。每次从read中读失败，则计数+1。</td>\n</tr>\n<tr>\n<td>dirty</td>\n<td>map[interface{}]*entry</td>\n<td>包含最新写入的数据。当misses计数达到一定值，将其赋值给read。</td>\n</tr>\n<tr>\n<td><img src=\"../images/store/MIK-3m017z.png\" alt=\"\"></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type readOnly struct &#123;</span><br><span class=\"line\">    m  map[interface&#123;&#125;]*entry</span><br><span class=\"line\">    amended bool </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th>说明</th>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>m</td>\n<td>map[interface{}]*entry</td>\n<td>单纯的map结构</td>\n</tr>\n<tr>\n<td>amended</td>\n<td>bool</td>\n<td>Map.dirty的数据和这里的 m 中的数据不一样的时候，为true</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type entry struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;可见value是个指针类型，虽然read和dirty存在冗余情况（amended&#x3D;false），但是由于是指针类型，存储的空间应该不是问题</span><br><span class=\"line\">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Load</strong>操作<br>\n<img src=\"../images/store/MIK-Gt4C4J.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 因read只读，线程安全，优先读取</span><br><span class=\"line\">    read, _ :&#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">    e, ok :&#x3D; read.m[key]</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 如果read没有，并且dirty有新数据，那么去dirty中查找</span><br><span class=\"line\">    if !ok &amp;&amp; read.amended &#123;</span><br><span class=\"line\">        m.mu.Lock()</span><br><span class=\"line\">        &#x2F;&#x2F; 双重检查（原因是前文的if判断和加锁非原子的，害怕这中间发生故事）</span><br><span class=\"line\">        read, _ &#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">        e, ok &#x3D; read.m[key]</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; 如果read中还是不存在，并且dirty中有新数据</span><br><span class=\"line\">        if !ok &amp;&amp; read.amended &#123;</span><br><span class=\"line\">            e, ok &#x3D; m.dirty[key]</span><br><span class=\"line\">            &#x2F;&#x2F; m计数+1</span><br><span class=\"line\">            m.missLocked()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        m.mu.Unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        return nil, false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return e.load()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (m *Map) missLocked() &#123;</span><br><span class=\"line\">    m.misses++</span><br><span class=\"line\">    if m.misses &lt; len(m.dirty) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 将dirty置给read，因为穿透概率太大了(原子操作，耗时很小)</span><br><span class=\"line\">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class=\"line\">    m.dirty &#x3D; nil</span><br><span class=\"line\">    m.misses &#x3D; 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Delete</strong>操作<br>\n<img src=\"../images/store/MIK-42EnM3.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Map) Delete(key interface&#123;&#125;) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 读出read，断言为readOnly类型</span><br><span class=\"line\">    read, _ :&#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">    e, ok :&#x3D; read.m[key]</span><br><span class=\"line\">    &#x2F;&#x2F; 如果read中没有，并且dirty中有新元素，那么就去dirty中去找。这里用到了amended，当read与dirty不同时为true，说明dirty中有read没有的数据。</span><br><span class=\"line\">    </span><br><span class=\"line\">    if !ok &amp;&amp; read.amended &#123;</span><br><span class=\"line\">        m.mu.Lock()</span><br><span class=\"line\">        &#x2F;&#x2F; 再检查一次，因为前文的判断和锁不是原子操作，防止期间发生了变化。</span><br><span class=\"line\">        read, _ &#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">        e, ok &#x3D; read.m[key]</span><br><span class=\"line\">        </span><br><span class=\"line\">        if !ok &amp;&amp; read.amended &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 直接删除</span><br><span class=\"line\">            delete(m.dirty, key)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m.mu.Unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ok &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果read中存在该key，则将该value 赋值nil（采用标记的方式删除！）</span><br><span class=\"line\">        e.delete()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (e *entry) delete() (hadValue bool) &#123;</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 再次再一把数据的指针</span><br><span class=\"line\">        p :&#x3D; atomic.LoadPointer(&amp;e.p)</span><br><span class=\"line\">        if p &#x3D;&#x3D; nil || p &#x3D;&#x3D; expunged &#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; 原子操作</span><br><span class=\"line\">        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) &#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Store</strong>操作<br>\n<img src=\"../images/store/MIK-nXfPUQ.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Map) Store(key, value interface&#123;&#125;) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果m.read存在这个key，并且没有被标记删除，则尝试更新。</span><br><span class=\"line\">    read, _ :&#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">    if e, ok :&#x3D; read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 如果read不存在或者已经被标记删除</span><br><span class=\"line\">    m.mu.Lock()</span><br><span class=\"line\">    read, _ &#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">   </span><br><span class=\"line\">    if e, ok :&#x3D; read.m[key]; ok &#123; &#x2F;&#x2F; read 存在该key</span><br><span class=\"line\">    &#x2F;&#x2F; 如果entry被标记expunge，则表明dirty没有key，可添加入dirty，并更新entry。</span><br><span class=\"line\">        if e.unexpungeLocked() &#123; </span><br><span class=\"line\">            &#x2F;&#x2F; 加入dirty中，这儿是指针</span><br><span class=\"line\">            m.dirty[key] &#x3D; e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 更新value值</span><br><span class=\"line\">        e.storeLocked(&amp;value) </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else if e, ok :&#x3D; m.dirty[key]; ok &#123; &#x2F;&#x2F; dirty 存在该key，更新</span><br><span class=\"line\">        e.storeLocked(&amp;value)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else &#123; &#x2F;&#x2F; read 和 dirty都没有</span><br><span class=\"line\">        &#x2F;&#x2F; 如果read与dirty相同，则触发一次dirty刷新（因为当read重置的时候，dirty已置为nil了）</span><br><span class=\"line\">        if !read.amended &#123; </span><br><span class=\"line\">            &#x2F;&#x2F; 将read中未删除的数据加入到dirty中</span><br><span class=\"line\">            m.dirtyLocked() </span><br><span class=\"line\">            &#x2F;&#x2F; amended标记为read与dirty不相同，因为后面即将加入新数据。</span><br><span class=\"line\">            m.read.Store(readOnly&#123;m: read.m, amended: true&#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m.dirty[key] &#x3D; newEntry(value) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m.mu.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将read中未删除的数据加入到dirty中</span><br><span class=\"line\">func (m *Map) dirtyLocked() &#123;</span><br><span class=\"line\">    if m.dirty !&#x3D; nil &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    read, _ :&#x3D; m.read.Load().(readOnly)</span><br><span class=\"line\">    m.dirty &#x3D; make(map[interface&#123;&#125;]*entry, len(read.m))</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 遍历read。</span><br><span class=\"line\">    for k, e :&#x3D; range read.m &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 通过此次操作，dirty中的元素都是未被删除的，可见标记为expunged的元素不在dirty中！！！</span><br><span class=\"line\">        if !e.tryExpungeLocked() &#123;</span><br><span class=\"line\">            m.dirty[k] &#x3D; e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 判断entry是否被标记删除，并且将标记为nil的entry更新标记为expunge</span><br><span class=\"line\">func (e *entry) tryExpungeLocked() (isExpunged bool) &#123;</span><br><span class=\"line\">    p :&#x3D; atomic.LoadPointer(&amp;e.p)</span><br><span class=\"line\">    </span><br><span class=\"line\">    for p &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 将已经删除标记为nil的数据标记为expunged</span><br><span class=\"line\">        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) &#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p &#x3D; atomic.LoadPointer(&amp;e.p)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return p &#x3D;&#x3D; expunged</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 对entry尝试更新 （原子cas操作）</span><br><span class=\"line\">func (e *entry) tryStore(i *interface&#123;&#125;) bool &#123;</span><br><span class=\"line\">    p :&#x3D; atomic.LoadPointer(&amp;e.p)</span><br><span class=\"line\">    if p &#x3D;&#x3D; expunged &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p &#x3D; atomic.LoadPointer(&amp;e.p)</span><br><span class=\"line\">        if p &#x3D;&#x3D; expunged &#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; read里 将标记为expunge的更新为nil</span><br><span class=\"line\">func (e *entry) unexpungeLocked() (wasExpunged bool) &#123;</span><br><span class=\"line\">    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 更新entry</span><br><span class=\"line\">func (e *entry) storeLocked(i *interface&#123;&#125;) &#123;</span><br><span class=\"line\">    atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>sync.Map优缺点</li>\n</ol>\n<ul>\n<li>优点：读写分离提高效率</li>\n<li>缺点：不适合大量写的场景，会导致read map读不到数据然后跑到dirty map读取，这个时候是要加锁的，而且穿透率也上来了，可能会导致很多次read dirty的交换操作，性能较差</li>\n<li>适用场景：读多写少</li>\n</ul>\n<ol start=\"8\">\n<li>实现线程安全的map的优化思路</li>\n</ol>\n<ul>\n<li>sync.Map的加锁类似表锁，如果我们做到行锁，性能就可能上去</li>\n<li>对于一个大map，划分成多个小map，做一个路由map</li>\n</ul>\n","next":{"title":"【Go语言核心36讲】33. 临时对象池sync.Pool","link":"2021/02/23/2021-02-23-01"},"plink":"https://terence.segofun.com/2021/02/23/2021-02-23-02/"}