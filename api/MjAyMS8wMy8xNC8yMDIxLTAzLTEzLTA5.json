{"title":"【转载】Go 项目实战：实现一个 Redis(8) 之 TCC 分布式事务","date":"2021-03-13T16:29:50.000Z","date_formatted":{"ll":"Mar 14, 2021","L":"03/14/2021","MM-DD":"03-14"},"link":"2021/03/14/2021-03-13-09","comments":true,"tags":["golang实现redis"],"updated":"2022-10-17T01:08:12.568Z","content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\" target=\"_blank\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://mp.weixin.qq.com/s?src=11%C3%97tamp=1615648497&amp;ver=2944&amp;signature=KJOxWs5l0IhTPhEsbi-S8YOPV5ADosbu9y56wc96yxph6Dj5S4VsP76QPXjG0tYqME6AaxK4Zvq1Yq*amKhTuzskRjauHd9auNbw8AKDVuGSCVKCsrkPj9bVRmNgXIZR&amp;new=1\" target=\"_blank\">mp.weixin.qq.com</a></p>\n</blockquote>\n<p>本文是使用 golang 实现 redis 系列的第八篇， 将介绍如何在分布式缓存中使用 Try-Commit-Catch 方式来解决分布式一致性问题。</p>\n<p>godis 集群的源码在 <a href=\"https://github.com/HDT3213/godis/tree/master/src/cluster\" target=\"_blank\">https://github.com/HDT3213/godis/tree/master/src/cluster</a></p>\n<p>在<a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651444286&amp;idx=2&amp;sn=98811b01b8330b3448109dc6f7120036&amp;chksm=80bb0accb7cc83da95a7575f2577c4b078a38d675d68ab82723e77d29f3d82688efb6f447a73&amp;scene=21#wechat_redirect\" target=\"_blank\">上一篇文章</a>中我们使用一致性 hash 算法将缓存中的 key 分散到不同的服务器节点中，从而实现了分布式缓存。随之而来的问题是：一条指令 (比如 MSET) 可能需要多个节点同时执行，可能有些节点成功而另一部分节点失败。</p>\n<p>对于使用者而言这种部分成功部分失败的情况非常难以处理，所以我们需要保证 MSET 操作要么全部成功要么全部失败。</p>\n<h2 id=\"mset-命令在集群模式下的问题\">MSET 命令在集群模式下的问题<a title=\"#mset-命令在集群模式下的问题\" href=\"#mset-命令在集群模式下的问题\"></a></h2>\n<p>于是问题来了 DEL、MSET 等命令所涉及的 key 可能分布在不同的节点中，在集群模式下实现这类涉及多个 key 的命令最简单的方式当然是 For-Each 遍历 key 并向它们所在的节点发送相应的操作指令。以 MGET 命令的实现为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func MGet(cluster *Cluster, c redis.Connection, args [][]byte) redis.Reply &#123;</span><br><span class=\"line\">    if len(args) &lt; 2 &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(&quot;ERR wrong number of arguments for &#39;mget&#39; command&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 从参数列表中取出要读取的 key</span><br><span class=\"line\">    keys :&#x3D; make([]string, len(args)-1)</span><br><span class=\"line\">    for i :&#x3D; 1; i &lt; len(args); i++ &#123;</span><br><span class=\"line\">        keys[i-1] &#x3D; string(args[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    resultMap :&#x3D; make(map[string][]byte)</span><br><span class=\"line\">    &#x2F;&#x2F; 计算每个 key 所在的节点，并按照节点分组</span><br><span class=\"line\">    groupMap :&#x3D; cluster.groupBy(keys) </span><br><span class=\"line\">    &#x2F;&#x2F; groupMap 的类型为 map[string][]string，key 是节点的地址，value 是 keys 中属于该节点的 key 列表</span><br><span class=\"line\">    for peer, group :&#x3D; range groupMap &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 向每个节点发送 mget 指令，读取分布在它上面的 key</span><br><span class=\"line\">        resp :&#x3D; cluster.Relay(peer, c, makeArgs(&quot;MGET&quot;, group...))</span><br><span class=\"line\">        if reply.IsErrorReply(resp) &#123;</span><br><span class=\"line\">            errReply :&#x3D; resp.(reply.ErrorReply)</span><br><span class=\"line\">            return reply.MakeErrReply(fmt.Sprintf(&quot;ERR during get %s occurs: %v&quot;, group[0], errReply.Error()))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arrReply, _ :&#x3D; resp.(*reply.MultiBulkReply)</span><br><span class=\"line\">        &#x2F;&#x2F; 将每个节点上的结果 merge 到 map 中</span><br><span class=\"line\">        for i, v :&#x3D; range arrReply.Args &#123;</span><br><span class=\"line\">            key :&#x3D; group[i]</span><br><span class=\"line\">            resultMap[key] &#x3D; v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result :&#x3D; make([][]byte, len(keys))</span><br><span class=\"line\">    for i, k :&#x3D; range keys &#123;</span><br><span class=\"line\">        result[i] &#x3D; resultMap[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return reply.MakeMultiBulkReply(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 计算 key 所属的节点，并按节点分组</span><br><span class=\"line\">func (cluster *Cluster) groupBy(keys []string) map[string][]string &#123;</span><br><span class=\"line\">    result :&#x3D; make(map[string][]string)</span><br><span class=\"line\">    for _, key :&#x3D; range keys &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 使用一致性 hash 计算所属节点</span><br><span class=\"line\">        peer :&#x3D; cluster.peerPicker.Get(key)</span><br><span class=\"line\">        &#x2F;&#x2F; 将 key 加入到相应节点的分组中</span><br><span class=\"line\">        group, ok :&#x3D; result[peer]</span><br><span class=\"line\">        if !ok &#123;</span><br><span class=\"line\">            group &#x3D; make([]string, 0)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        group &#x3D; append(group, key)</span><br><span class=\"line\">        result[peer] &#x3D; group</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>那么 MSET 命令的实现能否如法炮制呢？答案是否定的。在上面的代码中我们注意到，在向各个节点发送指令时若某个节点读取失败则会直接退出整个 MGET 执行过程。</p>\n<p>若在执行 MSET 指令时遇到部分节点失败或超时，则会出现部分 key 设置成功而另一份设置失败的情况。对于缓存使用者而言这种部分成功部分失败的情况非常难以处理，所以我们需要保证 MSET 操作要么全部成功要么全部失败。</p>\n<h2 id=\"两阶段提交\">两阶段提交<a title=\"#两阶段提交\" href=\"#两阶段提交\"></a></h2>\n<p>两阶段提交 (2-Phase Commit, 2PC) 算法是解决我们遇到的一致性问题最简单的算法。在 2PC 算法中写操作被分为两个阶段来执行:</p>\n<ol>\n<li>\n<p>Prepare 阶段</p>\n</li>\n<li>\n<p>协调者向所有参与者发送事务内容，询问是否可以执行事务操作。在 Godis 中收到客户端 MSET 命令的节点是事务的协调者，所有持有相关 key 的节点都要参与事务。</p>\n</li>\n<li>\n<p>各参与者锁定事务相关 key 防止被其它操作修改。各参与者写 undo log 准备在事务失败后进行回滚。</p>\n</li>\n<li>\n<p>参与者回复协调者可以提交。若协调者收到所有参与者的 YES 回复，则准备进行事务提交。若有参与者回复 NO 或者超时，则准备回滚事务</p>\n</li>\n<li>\n<p>Commit 阶段</p>\n</li>\n<li>\n<p>协调者向所有参与者发送提交请求</p>\n</li>\n<li>\n<p>参与者正式提交事务，并在完成后释放相关 key 的锁。</p>\n</li>\n<li>\n<p>参与者协调者回复 ACK，协调者收到所有参与者的 ACK 后认为事务提交成功。</p>\n</li>\n<li>\n<p>Rollback 阶段</p>\n</li>\n<li>\n<p>在事务请求阶段若有参与者回复 NO 或者超时，协调者向所有参与者发出回滚请求</p>\n</li>\n<li>\n<p>各参与者执行事务回滚，并在完成后释放相关资源。</p>\n</li>\n<li>\n<p>参与者协调者回复 ACK，协调者收到所有参与者的 ACK 后认为事务回滚成功。</p>\n</li>\n</ol>\n<p>2PC 是一种简单的一致性协议，它存在一些问题:</p>\n<ul>\n<li>\n<p>单点服务: 若协调者突然崩溃则事务流程无法继续进行或者造成状态不一致</p>\n</li>\n<li>\n<p>无法保证一致性: 若协调者第二阶段发送提交请求时崩溃，可能部分参与者受到 COMMIT 请求提交了事务，而另一部分参与者未受到请求而放弃事务造成不一致现象。</p>\n</li>\n<li>\n<p>阻塞: 为了保证事务完成提交，各参与者在完成第一阶段事务执行后必须锁定相关资源直到正式提交，影响系统的吞吐量。</p>\n</li>\n</ul>\n<p>首先我们定义事务的描述结构:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Transaction struct &#123;</span><br><span class=\"line\">    id      string   &#x2F;&#x2F; 事务 ID, 由 snowflake 算法生成</span><br><span class=\"line\">    args    [][]byte &#x2F;&#x2F; 命令参数</span><br><span class=\"line\">    cluster *Cluster</span><br><span class=\"line\">    conn    redis.Connection</span><br><span class=\"line\"></span><br><span class=\"line\">    keys    []string          &#x2F;&#x2F; 事务中涉及的 key</span><br><span class=\"line\">    undoLog map[string][]byte &#x2F;&#x2F; 每个 key 在事务执行前的值，用于回滚事务</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>###Prepare 阶段</p>\n<p>先看事务参与者 prepare 阶段的操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; prepare 命令的格式是: PrepareMSet TxID key1, key2 ...</span><br><span class=\"line\">&#x2F;&#x2F; TxID 是事务 ID，由协调者决定</span><br><span class=\"line\">func PrepareMSet(cluster *Cluster, c redis.Connection, args [][]byte) redis.Reply &#123;</span><br><span class=\"line\">    if len(args) &lt; 3 &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(&quot;ERR wrong number of arguments for &#39;preparemset&#39; command&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    txId :&#x3D; string(args[1])</span><br><span class=\"line\">    size :&#x3D; (len(args) - 2) &#x2F; 2</span><br><span class=\"line\">    keys :&#x3D; make([]string, size)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; size; i++ &#123;</span><br><span class=\"line\">        keys[i] &#x3D; string(args[2*i+2])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    txArgs :&#x3D; [][]byte&#123;</span><br><span class=\"line\">        []byte(&quot;MSet&quot;),</span><br><span class=\"line\">    &#125; &#x2F;&#x2F; actual args for cluster.db</span><br><span class=\"line\">    txArgs &#x3D; append(txArgs, args[2:]...)</span><br><span class=\"line\">    tx :&#x3D; NewTransaction(cluster, c, txId, txArgs, keys) &#x2F;&#x2F; 创建新事务</span><br><span class=\"line\">    cluster.transactions.Put(txId, tx) &#x2F;&#x2F; 存储到节点的事务列表中</span><br><span class=\"line\">    err :&#x3D; tx.prepare() &#x2F;&#x2F; 准备事务</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(err.Error())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &amp;reply.OkReply&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>实际的准备操作在 tx.prepare() 中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (tx *Transaction) prepare() error &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 锁定相关 key</span><br><span class=\"line\">    tx.cluster.db.Locks(tx.keys...)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 准备 undo log</span><br><span class=\"line\">    tx.undoLog &#x3D; make(map[string][]byte)</span><br><span class=\"line\">    for _, key :&#x3D; range tx.keys &#123;</span><br><span class=\"line\">        entity, ok :&#x3D; tx.cluster.db.Get(key)</span><br><span class=\"line\">        if ok &#123;</span><br><span class=\"line\">            blob, err :&#x3D; gob.Marshal(entity) &#x2F;&#x2F; 将修改之前的状态序列化之后存储作为 undo log</span><br><span class=\"line\">            if err !&#x3D; nil &#123;</span><br><span class=\"line\">                return err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tx.undoLog[key] &#x3D; blob</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">           &#x2F;&#x2F; 若事务执行前 key 是空的，在回滚时应删除它</span><br><span class=\"line\">            tx.undoLog[key] &#x3D; []byte&#123;&#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tx.status &#x3D; PreparedStatus</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>看看协调者在做什么:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func MSet(cluster *Cluster, c redis.Connection, args [][]byte) redis.Reply &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;  解析参数</span><br><span class=\"line\">    argCount :&#x3D; len(args) - 1</span><br><span class=\"line\">    if argCount%2 !&#x3D; 0 || argCount &lt; 1 &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(&quot;ERR wrong number of arguments for &#39;mset&#39; command&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size :&#x3D; argCount &#x2F; 2</span><br><span class=\"line\">    keys :&#x3D; make([]string, size)</span><br><span class=\"line\">    valueMap :&#x3D; make(map[string]string)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; size; i++ &#123;</span><br><span class=\"line\">        keys[i] &#x3D; string(args[2*i+1])</span><br><span class=\"line\">        valueMap[keys[i]] &#x3D; string(args[2*i+2])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 找到所属的节点</span><br><span class=\"line\">    groupMap :&#x3D; cluster.groupBy(keys)</span><br><span class=\"line\">    if len(groupMap) &#x3D;&#x3D; 1 &#123; &#x2F;&#x2F; do fast</span><br><span class=\"line\">        &#x2F;&#x2F; 若所有的 key 都在同一个节点直接执行，不使用较慢的 2pc 算法</span><br><span class=\"line\">        for peer :&#x3D; range groupMap &#123;</span><br><span class=\"line\">            return cluster.Relay(peer, c, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 开始准备阶段</span><br><span class=\"line\">    var errReply redis.Reply</span><br><span class=\"line\">    txId :&#x3D; cluster.idGenerator.NextId() &#x2F;&#x2F; 使用 snowflake 算法决定事务 ID</span><br><span class=\"line\">    txIdStr :&#x3D; strconv.FormatInt(txId, 10)</span><br><span class=\"line\">    rollback :&#x3D; false</span><br><span class=\"line\">    &#x2F;&#x2F; 向所有参与者发送 prepare 请求</span><br><span class=\"line\">    for peer, group :&#x3D; range groupMap &#123;</span><br><span class=\"line\">        peerArgs :&#x3D; []string&#123;txIdStr&#125;</span><br><span class=\"line\">        for _, k :&#x3D; range group &#123;</span><br><span class=\"line\">            peerArgs &#x3D; append(peerArgs, k, valueMap[k])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var resp redis.Reply</span><br><span class=\"line\">        if peer &#x3D;&#x3D; cluster.self &#123;</span><br><span class=\"line\">            resp &#x3D; PrepareMSet(cluster, c, makeArgs(&quot;PrepareMSet&quot;, peerArgs...))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            resp &#x3D; cluster.Relay(peer, c, makeArgs(&quot;PrepareMSet&quot;, peerArgs...))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if reply.IsErrorReply(resp) &#123;</span><br><span class=\"line\">            errReply &#x3D; resp</span><br><span class=\"line\">            rollback &#x3D; true</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if rollback &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 若 prepare 过程出错则执行回滚</span><br><span class=\"line\">        RequestRollback(cluster, c, txId, groupMap)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        _, errReply &#x3D; RequestCommit(cluster, c, txId, groupMap)</span><br><span class=\"line\">        rollback &#x3D; errReply !&#x3D; nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if !rollback &#123;</span><br><span class=\"line\">        return &amp;reply.OkReply&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return errReply</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-阶段\">Commit 阶段<a title=\"#commit-阶段\" href=\"#commit-阶段\"></a></h3>\n<p>事务参与者提交本地事务:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Commit(cluster *Cluster, c redis.Connection, args [][]byte) redis.Reply &#123;</span><br><span class=\"line\">    if len(args) !&#x3D; 2 &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(&quot;ERR wrong number of arguments for &#39;commit&#39; command&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 读取事务信息</span><br><span class=\"line\">    txId :&#x3D; string(args[1])</span><br><span class=\"line\">    raw, ok :&#x3D; cluster.transactions.Get(txId)</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        return reply.MakeIntReply(0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tx, _ :&#x3D; raw.(*Transaction)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 在提交成功后解锁 key</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        cluster.db.UnLocks(tx.keys...)</span><br><span class=\"line\">        tx.status &#x3D; CommitedStatus</span><br><span class=\"line\">        &#x2F;&#x2F;cluster.transactions.Remove(tx.id) &#x2F;&#x2F; cannot remove, may rollback after commit</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    cmd :&#x3D; strings.ToLower(string(tx.args[0]))</span><br><span class=\"line\">    var result redis.Reply</span><br><span class=\"line\">    if cmd &#x3D;&#x3D; &quot;del&quot; &#123;</span><br><span class=\"line\">        result &#x3D; CommitDel(cluster, c, tx)</span><br><span class=\"line\">    &#125; else if cmd &#x3D;&#x3D; &quot;mset&quot; &#123;</span><br><span class=\"line\">        result &#x3D; CommitMSet(cluster, c, tx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 提交失败</span><br><span class=\"line\">    if reply.IsErrorReply(result) &#123;</span><br><span class=\"line\">        err2 :&#x3D; tx.rollback()</span><br><span class=\"line\">        return reply.MakeErrReply(fmt.Sprintf(&quot;err occurs when rollback:  %v, origin err: %s&quot;, err2, result))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 执行操作</span><br><span class=\"line\">func CommitMSet(cluster *Cluster, c redis.Connection, tx *Transaction) redis.Reply &#123;</span><br><span class=\"line\">    size :&#x3D; len(tx.args) &#x2F; 2</span><br><span class=\"line\">    keys :&#x3D; make([]string, size)</span><br><span class=\"line\">    values :&#x3D; make([][]byte, size)</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; size; i++ &#123;</span><br><span class=\"line\">        keys[i] &#x3D; string(tx.args[2*i+1])</span><br><span class=\"line\">        values[i] &#x3D; tx.args[2*i+2]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for i, key :&#x3D; range keys &#123;</span><br><span class=\"line\">        value :&#x3D; values[i]</span><br><span class=\"line\">        cluster.db.Put(key, &amp;db.DataEntity&#123;Data: value&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cluster.db.AddAof(reply.MakeMultiBulkReply(tx.args))</span><br><span class=\"line\">    return &amp;reply.OkReply&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>协调者的逻辑也很简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func RequestCommit(cluster *Cluster, c redis.Connection, txId int64, peers map[string][]string) ([]redis.Reply, reply.ErrorReply) &#123;</span><br><span class=\"line\">    var errReply reply.ErrorReply</span><br><span class=\"line\">    txIdStr :&#x3D; strconv.FormatInt(txId, 10)</span><br><span class=\"line\">    respList :&#x3D; make([]redis.Reply, 0, len(peers))</span><br><span class=\"line\">    for peer :&#x3D; range peers &#123;</span><br><span class=\"line\">        var resp redis.Reply</span><br><span class=\"line\">        if peer &#x3D;&#x3D; cluster.self &#123;</span><br><span class=\"line\">            resp &#x3D; Commit(cluster, c, makeArgs(&quot;commit&quot;, txIdStr))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            resp &#x3D; cluster.Relay(peer, c, makeArgs(&quot;commit&quot;, txIdStr))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if reply.IsErrorReply(resp) &#123;</span><br><span class=\"line\">            errReply &#x3D; resp.(reply.ErrorReply)</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        respList &#x3D; append(respList, resp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if errReply !&#x3D; nil &#123;</span><br><span class=\"line\">        RequestRollback(cluster, c, txId, peers)</span><br><span class=\"line\">        return nil, errReply</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return respList, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"rollback\">Rollback<a title=\"#rollback\" href=\"#rollback\"></a></h3>\n<p>回滚本地事务:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Rollback(cluster *Cluster, c redis.Connection, args [][]byte) redis.Reply &#123;</span><br><span class=\"line\">    if len(args) !&#x3D; 2 &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(&quot;ERR wrong number of arguments for &#39;rollback&#39; command&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    txId :&#x3D; string(args[1])</span><br><span class=\"line\">    raw, ok :&#x3D; cluster.transactions.Get(txId)</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        return reply.MakeIntReply(0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tx, _ :&#x3D; raw.(*Transaction)</span><br><span class=\"line\">    err :&#x3D; tx.rollback()</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        return reply.MakeErrReply(err.Error())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return reply.MakeIntReply(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (tx *Transaction) rollback() error &#123;</span><br><span class=\"line\">    for key, blob :&#x3D; range tx.undoLog &#123;</span><br><span class=\"line\">        if len(blob) &gt; 0 &#123;</span><br><span class=\"line\">            entity :&#x3D; &amp;db.DataEntity&#123;&#125;</span><br><span class=\"line\">            err :&#x3D; gob.UnMarshal(blob, entity) &#x2F;&#x2F; 反序列化事务前的快照</span><br><span class=\"line\">            if err !&#x3D; nil &#123;</span><br><span class=\"line\">                return err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tx.cluster.db.Put(key, entity) &#x2F;&#x2F; 写入事务前的数据</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            tx.cluster.db.Remove(key) &#x2F;&#x2F; 若事务开始之前 key 不存在则将其删除</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if tx.status !&#x3D; CommitedStatus &#123;</span><br><span class=\"line\">        tx.cluster.db.UnLocks(tx.keys...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tx.status &#x3D; RollbackedStatus</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>协调者的逻辑与 commit 类似:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func RequestRollback(cluster *Cluster, c redis.Connection, txId int64, peers map[string][]string) &#123;</span><br><span class=\"line\">    txIdStr :&#x3D; strconv.FormatInt(txId, 10)</span><br><span class=\"line\">    for peer :&#x3D; range peers &#123;</span><br><span class=\"line\">        if peer &#x3D;&#x3D; cluster.self &#123;</span><br><span class=\"line\">            Rollback(cluster, c, makeArgs(&quot;rollback&quot;, txIdStr))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            cluster.Relay(peer, c, makeArgs(&quot;rollback&quot;, txIdStr))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作者：finley</p>\n<p>出处：<a href=\"https://www.cnblogs.com/Finley/p/14079108.html\" target=\"_blank\">https://www.cnblogs.com/Finley/p/14079108.html</a></p>\n<p>版权：本作品采用「署名 - 非商业性使用 - 相同方式共享 4.0 国际」许可协议进行许可。</p>\n</blockquote>\n<p><strong>推荐阅读</strong></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651444286&amp;idx=2&amp;sn=98811b01b8330b3448109dc6f7120036&amp;chksm=80bb0accb7cc83da95a7575f2577c4b078a38d675d68ab82723e77d29f3d82688efb6f447a73&amp;scene=21#wechat_redirect\" target=\"_blank\">Go 项目实战：实现一个 Redis(7) 之集群与一致性 Hash</a></strong></p>\n","prev":{"title":"【转载】Go 项目实战：实现一个 Redis(9) 之 使用 GeoHash 搜索附近的人","link":"2021/03/14/2021-03-13-10"},"next":{"title":"【转载】Go 项目实战：实现一个 Redis(7) 之集群与一致性 Hash","link":"2021/03/14/2021-03-13-08"},"plink":"https://terence.segofun.com/2021/03/14/2021-03-13-09/","toc":[{"id":"mset-命令在集群模式下的问题","title":"MSET 命令在集群模式下的问题","index":"1"},{"id":"两阶段提交","title":"两阶段提交","index":"2","children":[{"id":"commit-阶段","title":"Commit 阶段","index":"2.1"},{"id":"rollback","title":"Rollback","index":"2.2"}]}],"reading_time":"2816 words in 19 min"}