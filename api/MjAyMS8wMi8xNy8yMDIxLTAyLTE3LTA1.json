{"title":"【Go语言核心36讲】4/5/6. 程序实体的那些事儿","date":"2021-02-17T10:13:32.000Z","date_formatted":{"ll":"Feb 17, 2021","L":"02/17/2021","MM-DD":"02-17"},"link":"2021/02/17/2021-02-17-05","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-17T15:39:36.854Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>程序实体的构成：变量、常量、函数、结构体和接口</p>\n</li>\n<li>\n<p>变量的声明方式<br>\n<img src=\"../images/store/ShvXAe.png\" alt=\"\"></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用var name string，指明了类型</span><br><span class=\"line\">使用var name &#x3D; &quot;robert&quot;，没有指明类型，会进行类型推断</span><br><span class=\"line\"></span><br><span class=\"line\">对于:&#x3D;，象牙符，没有指明类型，也是要进行类型推断的</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量声明时类型推断的好处：</li>\n</ol>\n<ul>\n<li>对重构有一定好处，比如以前传结构体副本，现在传结构体指针什么的，但是未来有了泛型就会更好一些</li>\n<li>动态确定变量的类型，使得程序灵活性上升，维护成本上升，可读性也下降了</li>\n</ul>\n<ol start=\"4\">\n<li>\n<p>Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响</p>\n</li>\n<li>\n<p>变量的重声明，在同一个作用域下，原则上是不允许变量的重声明，但是如果使用了:=象牙运算符进行重声明是允许的</p>\n</li>\n<li>\n<p>Go 语言的类型推断只应用在了对变量或常量的初始化方面，也就是如果程序通过了编译，那么程序在运行中发生变量的类型的改变，是有可能发生的</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>其他阅读</p>\n<p>看到一段比较有意思的说明，关于重声明的</p>\n</blockquote>\n<p>所谓“变量的重声明”容易引发歧义，而且也不容易理解。如果没有为变量分配一块新的内存区域，那么用声明是不恰当的。在《Go 语言圣经》一书中将短声明的这种特性称为赋值。个人总结如下：</p>\n<p>在使用短变量声明的时候，你可能想要同时对一个已有的变量赋值，类似使用 <code>=</code> 进行多重赋值那样（如 <code>i, j = 2, 3</code>）。所以，Go 为短声明语法提供了一个语法糖（或者叫便利措施）：短变量声明不需要声明所有在左边的变量。如果多个变量在同一个词法块中声明，那么对于这些变量，短声明的行为等同于<em>赋值</em>。</p>\n<p>比如，在下面的代码中，第一条语句声明了 <code>in</code> 和 <code>err</code>。第二条语句仅声明了 <code>out</code>，但向已有的 <code>err</code> 变量进行赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in, err :&#x3D; os.Open(infile)</span><br><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">out, err :&#x3D; os.Create(outfile)</span><br></pre></td></tr></table></figure>\n<p>但是这种行为需要一些前提条件：</p>\n<ul>\n<li>要赋值的变量必须声明在同一个词法块中。</li>\n</ul>\n<p>如果两个变量位于不同的词法块中，短声明语法表示的仍然是“声明”而非“赋值”。此时它们就是重名的变量了，而且内层变量会“覆盖”外部变量。</p>\n<ul>\n<li>必须至少声明一个新变量，否则代码将不能编译通过。</li>\n</ul>\n<p>原因很简单，如果不用声明新变量而仅仅是为了赋值，那么直接使用赋值符 <code>=</code> 即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f, err :&#x3D; os.Open(infile)</span><br><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">&#x2F;&#x2F; f, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; 编译错误：没有新变量</span><br><span class=\"line\">f, err &#x3D; os.Create(outfile) &#x2F;&#x2F; 使用普通的赋值语句即可</span><br></pre></td></tr></table></figure>\n<hr>\n<ol start=\"7\">\n<li>如何判断变量类型？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 使用类型断言</span><br><span class=\"line\">var container &#x3D; []string&#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">value, ok :&#x3D; interface&#123;&#125;(container).([]string)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 如果判断正确，那么ok指为true，其他为false，同时会interface&#123;&#125;(container)的值会转换为[]string，然后赋值给value，注意 container本身的类型不变</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 类型断言表达式：x.(T)，x代表要被判断类型的值，这个值当下的类型必须是接口类型，具体是哪个接口类型无所谓</span><br><span class=\"line\">&#x2F;&#x2F; 例如container本身不是接口类型，就需要用interface空接口包装一下</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>\n<p>任何类型的值都可以很方便地被转换成空接口的值</p>\n</li>\n<li>\n<p>类型的分类：结构体类型，接口类型</p>\n</li>\n<li>\n<p>转换类型的时候，一定要注意大类型转换到小类型可能数据会被截断</p>\n</li>\n<li>\n<p>string byte rune</p>\n</li>\n</ol>\n<ul>\n<li>区分：unicode和utf8，unicode是字符集，utf8是编码规则，也就是go可以按照utf8规则转换为unicode字符</li>\n<li>byte === uint8, 区分字节值和8位无符号整数值</li>\n<li>rune === int32, 区分字符值和整数值</li>\n<li>string 底层是用byte实现的，所以一个unicode的每一个非中文值都会是一个字节，汉字是三个字节，存储在[]byte中</li>\n<li>rune，这种是存储unicode字符，所以对于汉字也是一个字符</li>\n<li>byte存储的是字节</li>\n<li>rune存储的是字符</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】7. 数组和切片","link":"2021/02/17/2021-02-17-06"},"next":{"title":"【Go语言核心36讲】3. 库源码文件","link":"2021/02/17/2021-02-17-04"},"plink":"https://terence.segofun.com/2021/02/17/2021-02-17-05/"}