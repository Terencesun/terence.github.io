{"title":"【Go语言核心36讲】25. 更多的测试手法","date":"2021-02-20T08:58:49.000Z","date_formatted":{"ll":"Feb 20, 2021","L":"02/20/2021","MM-DD":"02-20"},"link":"2021/02/20/2021-02-20-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2022-10-17T01:08:12.560Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\" target=\"_blank\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>-cpu的功能</li>\n</ol>\n<ul>\n<li>GPM模型：G是goroutine，用户级线程，M是machine，系统级线程（操作系统内核级别的线程），P是调度器</li>\n<li>Go 语言并发编程模型中的 P，正是 goroutine 的数量能够数十万计的关键所在。P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在</li>\n<li>go test命令的-cpu标记正是用于设置这个最大个数的</li>\n</ul>\n<ol start=\"2\">\n<li>怎样设置-cpu标记的值，以及它会对测试流程产生什么样的影响？</li>\n</ol>\n<ul>\n<li>go test -cpu [1,2,4] go test命令在进行准备工作的时候会读取-cpu标记的值，并把它转换为一个以int为元素类型的切片，我们也可以称它为逻辑 CPU 切片</li>\n<li>如果该命令发现我们并没有追加这个标记，那么就会让逻辑 CPU 切片只包含一个元素值，即最大 P 数量的默认值，也就是当前计算机 CPU 核心的实际数量</li>\n<li>无论该函数是功能测试函数，还是性能测试函数，go test命令都会迭代逻辑 CPU 切片，并且在每次迭代时，先依据当前的元素值设置最大 P 数量，然后再去执行测试函数</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>-count标记，专门用于重复执行测试函数的，默认为1，且需要&gt;=0</p>\n</li>\n<li>\n<p>go test -count 5 --&gt; 对于每一个测试函数，命令都会在预设的不同条件下(比如假设你设置了-cpu [1, 2, 4])分别重复执行5次</p>\n</li>\n<li>\n<p>go test -count 和 -cpu可以联合使用</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性能测试函数的执行次数 &#x3D; &#96;-cpu&#96;标记的值中正整数的个数 x &#96;-count&#96;标记的值 x 探索式执行中测试函数的实际执行次数</span><br><span class=\"line\"></span><br><span class=\"line\">功能测试函数的执行次数 &#x3D; &#96;-cpu&#96;标记的值中正整数的个数 x &#96;-count&#96;标记的值</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/store/hYSyeq.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<ol start=\"6\">\n<li>\n<p>在对 Go 程序执行某种自动化测试的过程中，测试日志会显得特别多，而且好多都是重复的，需要对日志进行精简</p>\n</li>\n<li>\n<p>我们的程序会无法避免地依赖一些外部环境，比如数据库或者其他服务。这时，我们依然不应该让测试的反复执行成为检测手段，而应该在测试中通过仿造（mock）外部环境，来规避掉它们的不确定性</p>\n</li>\n<li>\n<p>设置的最大 P 数量，最好不要超过当前计算机 CPU 核心的实际数量。因为一旦超出计算机实际的并行处理能力，Go 程序在性能上就无法再得到显著地提升了，可能会额外增加系统的计算资源</p>\n</li>\n<li>\n<p>-parallel标记的作用：</p>\n</li>\n</ol>\n<ul>\n<li>设置同一个被测试代码包中的功能测试函数的最大并发执行数</li>\n<li>在默认情况下，对于同一个被测代码包中的多个功能测试函数，命令会串行地执行它们</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; GetPrimes 用于获取小于或等于参数max的所有质数。</span><br><span class=\"line\">&#x2F;&#x2F; 本函数使用的是爱拉托逊斯筛选法（Sieve Of Eratosthenes）。</span><br><span class=\"line\">func GetPrimes(max int) []int &#123;</span><br><span class=\"line\">\tif max &lt;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\treturn []int&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmarks :&#x3D; make([]bool, max)</span><br><span class=\"line\">\tvar count int</span><br><span class=\"line\">\tsquareRoot :&#x3D; int(math.Sqrt(float64(max)))</span><br><span class=\"line\">\tfor i :&#x3D; 2; i &lt;&#x3D; squareRoot; i++ &#123;</span><br><span class=\"line\">\t\tif marks[i] &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\t\tfor j :&#x3D; i * i; j &lt; max; j +&#x3D; i &#123;</span><br><span class=\"line\">\t\t\t\tif marks[j] &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\t\t\t\tmarks[j] &#x3D; true</span><br><span class=\"line\">\t\t\t\t\tcount++</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprimes :&#x3D; make([]int, 0, max-count)</span><br><span class=\"line\">\tfor i :&#x3D; 2; i &lt; max; i++ &#123;</span><br><span class=\"line\">\t\tif marks[i] &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\t\tprimes &#x3D; append(primes, i)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn primes</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var expectedPrimes &#x3D; []int&#123;</span><br><span class=\"line\">\t2, 3, 5, 7, 11, 13, 17, 19,</span><br><span class=\"line\">\t23, 29, 31, 37, 41, 43, 47, 53,</span><br><span class=\"line\">\t59, 61, 67, 71, 73, 79, 83, 89,</span><br><span class=\"line\">\t97, 101, 103, 107, 109, 113, 127, 131,</span><br><span class=\"line\">\t137, 139, 149, 151, 157, 163, 167, 173,</span><br><span class=\"line\">\t179, 181, 191, 193, 197, 199, 211, 223,</span><br><span class=\"line\">\t227, 229, 233, 239, 241, 251, 257, 263,</span><br><span class=\"line\">\t269, 271, 277, 281, 283, 293, 307, 311,</span><br><span class=\"line\">\t313, 317, 331, 337, 347, 349, 353, 359,</span><br><span class=\"line\">\t367, 373, 379, 383, 389, 397, 401, 409,</span><br><span class=\"line\">\t419, 421, 431, 433, 439, 443, 449, 457,</span><br><span class=\"line\">\t461, 463, 467, 479, 487, 491, 499, 503,</span><br><span class=\"line\">\t509, 521, 523, 541, 547, 557, 563, 569,</span><br><span class=\"line\">\t571, 577, 587, 593, 599, 601, 607, 613,</span><br><span class=\"line\">\t617, 619, 631, 641, 643, 647, 653, 659,</span><br><span class=\"line\">\t661, 673, 677, 683, 691, 701, 709, 719,</span><br><span class=\"line\">\t727, 733, 739, 743, 751, 757, 761, 769,</span><br><span class=\"line\">\t773, 787, 797, 809, 811, 821, 823, 827,</span><br><span class=\"line\">\t829, 839, 853, 857, 859, 863, 877, 881,</span><br><span class=\"line\">\t883, 887, 907, 911, 919, 929, 937, 941,</span><br><span class=\"line\">\t947, 953, 967, 971, 977, 983, 991, 997,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 这个测试完全依赖-parallel参数</span><br><span class=\"line\">func TestGetPrimesWithAbnormalParam(t *testing.T) &#123;</span><br><span class=\"line\">\tt.Parallel()</span><br><span class=\"line\">\tinvalidParams :&#x3D; []int&#123;1, 0, -1, -2, -3&#125;</span><br><span class=\"line\">\tfor _, ip :&#x3D; range invalidParams &#123;</span><br><span class=\"line\">\t\tresult :&#x3D; GetPrimes(ip)</span><br><span class=\"line\">\t\tif result &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(&quot;The result is nil, but it should not be.&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif len(result) &gt; 0 &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(&quot;The result is not empty, but it should be.&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 这个测试完全依赖-parallel参数</span><br><span class=\"line\">func TestGetPrimesWith1000(t *testing.T) &#123;</span><br><span class=\"line\">\tt.Parallel()</span><br><span class=\"line\">\tmax :&#x3D; 1000</span><br><span class=\"line\">\tprimes :&#x3D; GetPrimes(max)</span><br><span class=\"line\">\tfor i, prime :&#x3D; range primes &#123;</span><br><span class=\"line\">\t\texpectedPrime :&#x3D; expectedPrimes[i]</span><br><span class=\"line\">\t\tif prime !&#x3D; expectedPrime &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(&quot;%dth prime number %d is not the expected value %d&quot;,</span><br><span class=\"line\">\t\t\t\ti, prime, expectedPrime)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif t.Failed() &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\tt.Logf(&quot;The primes less than %d are all correct.&quot;, max)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 这个测试函数主要是创建了几个子测试并发执行 t.Run()</span><br><span class=\"line\">func TestGetPrimesParallel(t *testing.T) &#123;</span><br><span class=\"line\">\tfor _, max :&#x3D; range []int&#123;1, 2, 3, 4, 5&#125; &#123;</span><br><span class=\"line\">\t\tmax :&#x3D; max * 200</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 这些子测试会被并发地执行，</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 并且只有它们都执行完毕之后当前的测试函数才会执行完成。</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 当前的测试函数并不会与其他测试函数一起被并发的执行。</span><br><span class=\"line\">\t\tt.Run(fmt.Sprintf(&quot;TestGetPrimesWith%d&quot;, max),</span><br><span class=\"line\">\t\t\tfunc(t *testing.T) &#123;</span><br><span class=\"line\">\t\t\t\tt.Parallel()</span><br><span class=\"line\">\t\t\t\tprimes :&#x3D; GetPrimes(max)</span><br><span class=\"line\">\t\t\t\terr :&#x3D; comparePrimes(primes)</span><br><span class=\"line\">\t\t\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\t\tt.Error(err)</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tt.Logf(&quot;The primes less than %d are all correct.&quot;, max)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>强调一下，-parallel标记对性能测试是无效的。当然了，对于性能测试来说，也是可以并发进行的，不过机制上会有所不同</li>\n</ul>\n<ol start=\"10\">\n<li>性能测试函数中的计时器是做什么用的？</li>\n</ol>\n<ul>\n<li>testing.B类型有这么几个指针方法：StartTimer、StopTimer和ResetTimer，用于操作当前的性能测试函数专属的计时器的</li>\n<li>计时器，是一个逻辑上的概念，它其实是testing.B类型中一些字段的统称。这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func BenchmarkGetPrimes(b *testing.B) &#123;</span><br><span class=\"line\">\tb.StopTimer()  &#x2F;&#x2F; 先停止了当前测试函数的计时器</span><br><span class=\"line\">\ttime.Sleep(time.Millisecond * 500) &#x2F;&#x2F; 模拟某个耗时但与被测程序关系不大的操作。</span><br><span class=\"line\">\tmax :&#x3D; 10000</span><br><span class=\"line\">\tb.StartTimer()  &#x2F;&#x2F; 启动计时器</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class=\"line\">\t\tGetPrimes(max)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以想象一下，我们需要耗费额外的时间去确定max变量的值，虽然在后面它会被传入GetPrimes函数，但是，针对GetPrimes函数本身的性能测试并不应该包含确定参数值的过程</li>\n<li>我们需要把这个过程所耗费的时间，从当前测试函数的执行时间中去除掉。这样就能够避免这一过程对测试结果的不良影响了</li>\n<li>每当这个测试函数执行完毕后，go test命令拿到的执行时间都只应该包含调用GetPrimes函数所耗费的那些时间</li>\n<li>相比之下，b.ResetTimer方法的灵活性就要差一些了，它只能用于：去除在调用它之前那些代码的执行时间。不过，无论在调用它的时候，计时器是不是正在运行，它都可以起作用</li>\n</ul>\n<ol start=\"11\">\n<li>\n<p>-benchmem 输出基准测试的内存分配统计信息</p>\n</li>\n<li>\n<p>-benchtime 用于指定基准测试的探索式测试执行时间上限</p>\n</li>\n<li>\n<p>使用 -coverprofile=xxxx.out 输出覆盖率的out文件，使用go tool cover -html=xxxx.out 命令转换成Html的覆盖率测试报告。 覆盖率测试将被测试的代码拷贝一份，在每个语句块中加入bool标识变量，测试结束后统计覆盖率并输出成out文件，因此性能上会有一定的影响</p>\n</li>\n<li>\n<p>使用-covermode=count标识参数将插入的标识变量由bool类型转换为计数器，在测试过程中，记录执行次数，用于找出被频繁执行的代码块，方便优化</p>\n</li>\n</ol>\n","prev":{"title":"【Go语言核心36讲】26. sync.Mutex与sync.RWMutex","link":"2021/02/20/2021-02-20-02"},"next":{"title":"【Go语言核心36讲】23/24. 测试的基本规则和流程","link":"2021/02/19/2021-02-19-01"},"plink":"https://terence.segofun.com/2021/02/20/2021-02-20-01/","reading_time":"2169 words in 14 min"}