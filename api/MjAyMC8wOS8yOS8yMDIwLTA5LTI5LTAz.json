{"title":"【go】一个简单的负载均衡的框架实现","date":"2020-09-29T11:49:58.000Z","date_formatted":{"ll":"Sep 29, 2020","L":"09/29/2020","MM-DD":"09-29"},"link":"2020/09/29/2020-09-29-03","comments":true,"tags":["demo","golang"],"updated":"2020-09-29T13:26:56.705Z","content":"<h2 id=\"一个简单的负载均衡的框架实现\">一个简单的负载均衡的框架实现<a title=\"#一个简单的负载均衡的框架实现\" href=\"#一个简单的负载均衡的框架实现\"></a></h2>\n<hr>\n<blockquote>\n<p>最近在学习go接口和结构体，于是试着实现了一个负载均衡的框架，包括注册中心和两个负载均衡算法(robin和random)</p>\n</blockquote>\n<p><strong>STEP 1</strong><br>\n程序结构如下：</p>\n<p><img src=\"/images/2020-09-29-03/step1.jpg\" alt=\"\" class=\"φcx\"></p>\n<p>文件目录如下：</p>\n<p><img src=\"/images/2020-09-29-03/step1-2.png\" alt=\"\" class=\"φcx\"></p>\n<p><strong>STEP 2</strong></p>\n<p>模拟后端实例，我们写一个实例的结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件instance.go</span><br><span class=\"line\">package balance</span><br><span class=\"line\"></span><br><span class=\"line\">type Instance struct &#123;</span><br><span class=\"line\">\thost string</span><br><span class=\"line\">\tport int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *Instance) InitInstance(host string, port int) *Instance &#123;</span><br><span class=\"line\">\tp.host &#x3D; host</span><br><span class=\"line\">\tp.port &#x3D; port</span><br><span class=\"line\">\treturn p</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>STEP 3</strong><br>\n实现负载均衡的目的，就是在一堆实例中找到需要使用的实例</p>\n<p>我们创建一个balance的接口，用来表示每一种负载均衡算法需要实现的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件balance.go</span><br><span class=\"line\">package balance</span><br><span class=\"line\"></span><br><span class=\"line\">type Balancer interface &#123;</span><br><span class=\"line\">\tDoBalance([]*Instance) (*Instance, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>STEP 4</strong></p>\n<p>每当新增一个负载均衡算法的时候，我们希望有个地方能管理这些算法，方便以后扩展</p>\n<p>就需要一个Manager，用来管理算法</p>\n<p>Manager 是一个结构体，需要在全局有一个实例</p>\n<p>并且Manager需要记录算法实例，这里就采用map来记录</p>\n<p>最重要的是，Manager类似一个接口，把算法实现都黑盒了，所以这里需要有两个方法，注册和执行</p>\n<p>注册，用于发现算法，这里是由算法模块主动注册</p>\n<p>执行，用于筛选出算法后，得到负载实例的具体哪一个实例，然后让该实例执行任务</p>\n<p>具体代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件manager.go</span><br><span class=\"line\">package balance</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;errors&quot;</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Manager struct &#123;</span><br><span class=\"line\">\tmethods map[string]Balancer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ManagerInstance *Manager &#x3D; &amp;Manager&#123;</span><br><span class=\"line\">\tmethods: make(map[string]Balancer),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func RegisteBalancer(name string, balancer Balancer)  &#123;</span><br><span class=\"line\">\tManagerInstance.methods[name] &#x3D; balancer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func StartServer(name string, insts []*Instance)  &#123;</span><br><span class=\"line\">\tManagerInstance.DoBalance(name, insts)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *Manager) getBalancer(name string) (balancer Balancer, err error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif bal, ok :&#x3D; p.methods[name]; ok &#123;</span><br><span class=\"line\">\t\tbalancer &#x3D; bal</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\terr &#x3D; errors.New(&quot;get balancer fail.&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *Manager) DoBalance(name string, insts []*Instance)  &#123;</span><br><span class=\"line\">\tfmt.Printf(&quot;use strategy -&gt; %v\\n&quot;, name)</span><br><span class=\"line\">\tif method, err :&#x3D; p.getBalancer(name); err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tfor &#123;</span><br><span class=\"line\">\t\t\tif inst, err2 :&#x3D; method.DoBalance(insts); err2 &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(*inst)</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(err2)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * 1)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>STEP 5</strong><br>\n接下来需要实现算法模块了，建立一个算法的结构体，并且需要实现balance接口</p>\n<p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件random.go</span><br><span class=\"line\"></span><br><span class=\"line\">package balance</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;errors&quot;</span><br><span class=\"line\">\t&quot;math&#x2F;rand&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func init()  &#123;</span><br><span class=\"line\">\tRegisteBalancer(&quot;random&quot;, &amp;RandomBalance&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type RandomBalance struct &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *RandomBalance) DoBalance(insts []*Instance) (inst *Instance, err error) &#123;</span><br><span class=\"line\">\tif len(insts) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\terr &#x3D; errors.New(&quot;the instances should be haven.&quot;)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlens :&#x3D; len(insts)</span><br><span class=\"line\">\tindex :&#x3D; rand.Intn(lens)</span><br><span class=\"line\">\tinst &#x3D; insts[index]</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件robin.go</span><br><span class=\"line\"></span><br><span class=\"line\">package balance</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;errors&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func init()  &#123;</span><br><span class=\"line\">\tRegisteBalancer(&quot;robin&quot;, &amp;RobinBalance&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type RobinBalance struct &#123;</span><br><span class=\"line\">\tcurIndex int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *RobinBalance) DoBalance(insts []*Instance) (inst *Instance, err error) &#123;</span><br><span class=\"line\">\tif len(insts) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\terr &#x3D; errors.New(&quot;the instances should be haven.&quot;)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlens :&#x3D; len(insts)</span><br><span class=\"line\">\tif p.curIndex &gt; lens &#123;</span><br><span class=\"line\">\t\tp.curIndex &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tinst &#x3D; insts[p.curIndex]</span><br><span class=\"line\">\tp.curIndex &#x3D; (p.curIndex + 1) % lens</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>STEP 6</strong></p>\n<p>现在balance模块已经完成，我们开始写main来调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件main.go</span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;balanceWrite&#x2F;balance&quot;</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;os&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main()  &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建模拟实例</span><br><span class=\"line\">\tinsts :&#x3D; make([]*balance.Instance, 0)</span><br><span class=\"line\">\tfor i:&#x3D;0; i&lt;16; i++ &#123;</span><br><span class=\"line\">\t\thost :&#x3D; fmt.Sprintf(&quot;192.168.1.%v&quot;, i)</span><br><span class=\"line\">\t\tone :&#x3D; new(balance.Instance).InitInstance(host, 8080)</span><br><span class=\"line\">\t\tinsts &#x3D; append(insts, one)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 默认的负载均衡算法</span><br><span class=\"line\">\tbalancer :&#x3D; &quot;robin&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 可以通过参数来指定算法</span><br><span class=\"line\">\tif len(os.Args) &gt; 1 &#123;</span><br><span class=\"line\">\t\tbalancer &#x3D; os.Args[1]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 开始执行负载均衡</span><br><span class=\"line\">\tbalance.StartServer(balancer, insts)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","next":{"title":"【Coding Mind】Rob Pike 的 5个编程原则","link":"2020/09/29/2020-09-29-02"},"plink":"https://terence.segofun.com/2020/09/29/2020-09-29-03/","toc":[{"id":"一个简单的负载均衡的框架实现","title":"一个简单的负载均衡的框架实现","index":"1"}]}