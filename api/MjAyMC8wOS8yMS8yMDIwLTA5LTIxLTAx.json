{"title":"【算法】排序算法-冒泡排序和选择排序","date":"2020-09-21T02:12:32.000Z","date_formatted":{"ll":"Sep 21, 2020","L":"09/21/2020","MM-DD":"09-21"},"link":"2020/09/21/2020-09-21-01","comments":true,"tags":["algorithm"],"updated":"2022-10-17T01:08:12.550Z","content":"<h3 id=\"排序算法-冒泡排序和选择排序\">排序算法-冒泡排序和选择排序<a title=\"#排序算法-冒泡排序和选择排序\" href=\"#排序算法-冒泡排序和选择排序\"></a></h3>\n<hr>\n<p><strong>1. 背景</strong></p>\n<p>由于冒泡排序和选择排序的思想很类似，所以，在网上会有很多把选择排序当做冒泡排序的例子</p>\n<p><strong>2. 冒泡排序的思想</strong></p>\n<p>每一次排序过程，通过相邻元素的交换，将当前没有排好序中的最大（小）移到数组的最右（左）端</p>\n<p><img src=\"/images/2020-09-21-01/bubble.gif\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>3.选择排序的思想</strong></p>\n<p>每一次排序过程，我们获取当前没有排好序中的最大（小）的元素和数组最右（左）端的元素交换，循环这个过程即可实现对整个数组排序</p>\n<p><img src=\"/images/2020-09-21-01/select.gif\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>4.冒泡的代码实现(简单粗暴版)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestBubbleSort(t *testing.T)  &#123;</span><br><span class=\"line\">\ttemp :&#x3D; []int&#123;3, 1, 9, 10, 8, 2&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 最外层循环，用以循环冒泡次数</span><br><span class=\"line\">    &#x2F;&#x2F; 每冒泡出去一个元素，就需要一次最外层循环</span><br><span class=\"line\">\tfor i:&#x3D;0; i&lt;len(temp); i++ &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 内层循环，相邻两数比较大小，如果满足if中的条件，进行两数的交换</span><br><span class=\"line\">        &#x2F;&#x2F; 冒泡出去的元素，排序已经确定，如果下面的，每次冒泡出去的，都是当前无序元素中最大的</span><br><span class=\"line\">        &#x2F;&#x2F; 冒泡的过程就是，无序元素 -&gt; 有序元素过渡</span><br><span class=\"line\">\t\tfor j:&#x3D;0; j&lt;len(temp)-i-1;j++ &#123;</span><br><span class=\"line\">\t\t\tif temp[j] &gt; temp[j+1] &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 进行交换</span><br><span class=\"line\">\t\t\t\ttemp[j], temp[j+1] &#x3D; temp[j+1], temp[j]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(temp)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>5.选择的代码实现(简单粗暴版)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestSelectSort(t *testing.T)  &#123;</span><br><span class=\"line\">\ttemp :&#x3D; []int&#123;3, 1, 9, 10, 8, 2&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 最外层循环，每次选择最大或最小的数，然后放入有序元素中</span><br><span class=\"line\">\tfor i:&#x3D;0; i&lt;len(temp); i++ &#123;</span><br><span class=\"line\">\t\tfor j:&#x3D;i+1; j&lt;len(temp);j++ &#123;</span><br><span class=\"line\">\t\t\tif temp[i] &gt; temp[j] &#123;</span><br><span class=\"line\">\t\t\t\ttemp[i], temp[j] &#x3D; temp[j], temp[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(temp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>6.冒泡排序和选择排序的区别</strong></p>\n<ul>\n<li>\n<p>冒泡排序是相邻两数之间比较和互换，最后让最大或最小的数从无序元素中冒泡到有序元素中(可以想象为大海中一个泡泡吐到湖面上，大海就是无序的，湖面是有序的)</p>\n</li>\n<li>\n<p>选择排序是从无须中找出最大或最小的，把其放到有序元素中，这个概念导致冒泡和选择很类似</p>\n</li>\n</ul>\n","prev":{"title":"【算法】排序算法-插入排序","link":"2020/09/21/2020-09-21-02"},"plink":"https://terence.segofun.com/2020/09/21/2020-09-21-01/","toc":[{"id":"排序算法-冒泡排序和选择排序","title":"排序算法-冒泡排序和选择排序","index":"1"}],"reading_time":"597 words in 4 min"}