{"title":"【Go语言核心36讲】44/45. 使用os包中的API","date":"2021-03-12T15:05:44.000Z","date_formatted":{"ll":"Mar 12, 2021","L":"03/12/2021","MM-DD":"03-12"},"link":"2021/03/12/2021-03-12-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-03-12T15:46:47.333Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>\n<p>os包中的API主要帮助我们使用操作系统的文件系统、权限系统、环境变量、系统进程和系统信号</p>\n</li>\n<li>\n<p>os.File是常用的数据类型</p>\n</li>\n</ol>\n<ul>\n<li>Unix操作系统中，一切都可以看做是文件</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>os.File类型拥有的都是指针方法，不但可以通过各种方式读取和写入某个文件中的内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭</p>\n</li>\n<li>\n<p>os中的函数，Create\\NewFile\\Open\\OpenFile</p>\n</li>\n</ol>\n<ul>\n<li>os.Create用于给定的路径创建一个新的文件，会返回一个File值和一个错误值</li>\n<li>使用这个函数创建的文件，对于操作系统中的所有用户来说，都是可以读和写的</li>\n<li>os.NewFile函数，使用的时候，需要一个代表文件描述符合uintptr类型的值，和一个表示文件名的字符串值</li>\n<li>不要被这个函数的名称误导了，它的功能并不是创建一个新的文件，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的File值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 文件描述符，是由通常很小的非负整数代表的</span><br><span class=\"line\">&#x2F;&#x2F; 一般会由 I&#x2F;O 相关的系统调用返回，并作为某个文件的一个标识存在</span><br><span class=\"line\">&#x2F;&#x2F; 从操作系统的层面看，针对任何文件的 I&#x2F;O 操作都需要用到这个文件描述符</span><br><span class=\"line\">&#x2F;&#x2F; Go 语言中的一些数据类型，为我们隐匿掉了这个描述符，如此一来我们就无需时刻关注和辨别它了</span><br><span class=\"line\">&#x2F;&#x2F; 下面这个就是标准错误输出的描述符，表示的是我们会用这个描述符向&#x2F;dev&#x2F;stderr文件中写入数据</span><br><span class=\"line\">file3 :&#x3D; os.NewFile(uintptr(syscall.Stderr), &quot;&#x2F;dev&#x2F;stderr&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if file3 !&#x3D; nil &#123;</span><br><span class=\"line\"> defer file3.Close()</span><br><span class=\"line\"> &#x2F;&#x2F; 注意这里就是单纯的写操作，通过标准错误输出的描述符</span><br><span class=\"line\"> file3.WriteString(</span><br><span class=\"line\">  &quot;The Go language program writes the contents into stderr.\\n&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>os.Open函数会打开一个文件并返回包装了该文件的File值，注意打开后，只能以只读方式访问</li>\n<li>os.OpenFile函数，最为灵活，单独拿出来说</li>\n</ul>\n<ol start=\"5\">\n<li>os.OpenFile</li>\n</ol>\n<ul>\n<li>三个参数 name/flag/perm，name就是文件路径，flag表示需要施加在文件描述符上的模式，操作模式，perm表示权限模式</li>\n<li>操作模式，可以有只读模式os.O_RDONLY，还有其他几种模式</li>\n<li>权限模式，是一个基于uint32的类型的别名类型os.FileMode<br>\n<img src=\"../images/store/M7EKzw.png\" alt=\"\"></li>\n</ul>\n<ol start=\"6\">\n<li>\n<p>通过os.File类型的值，我们不但可以对文件进行读取、写入、关闭等操作，还可以设定下一次读取或写入时的起始索引位置</p>\n</li>\n<li>\n<p>File的操作模式有哪些？</p>\n</li>\n</ol>\n<ul>\n<li>os.O_RDONLY -&gt; 只读</li>\n<li>os.O_WRONLY -&gt; 只写</li>\n<li>os.O_RDWR -&gt; 读写</li>\n<li>os.O_APPEND -&gt; 追加</li>\n<li>os.O_CREATE -&gt; 路径文件不存在，创建一个新文件</li>\n<li>os.O_EXCL -&gt; 需要和O_CREATE一起使用，表示在给定的路径上不能有已存在的文件</li>\n<li>os.O_SYNC -&gt; 在打开的文件上实施同步I/O</li>\n<li>os.O_TRUNC -&gt; 如果文件存在，就清空内容</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 使用按位或操作符组合，如下</span><br><span class=\"line\">func Create(name string) (*File, error) &#123;</span><br><span class=\"line\"> return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>File的权限操作有哪些？</li>\n</ol>\n<ul>\n<li>os.FileMode，代表的不只是权限模式，也可以代表文件模式</li>\n<li>os.FileMode是基于uint32类型的，总共有32个比特位，每个比特位都有特定的含义</li>\n<li>如果最高位比特位是1，那么就是表示这个文件是个目录</li>\n<li>如果第26个比特位上是1，就表示这个文件是个命名管道</li>\n<li>os.FileMode只有最低的9个比特位才用于表示文件的权限</li>\n<li>为了缩减写法，用一个八进制表示就是0777，表示最低位9个比特位都是1，更高的23个比特位都是0</li>\n<li>9个权限比特位中，没3个一组，共有3组</li>\n<li>这三组表示的是文件所有者(创建文件的那个用户)、文件所有者所属的用户组、其他用户 对于该文件的访问权限</li>\n<li>每组，其中3个比特位从高到底分别表示读权限、写权限和执行权限</li>\n<li>其中某个比特位上的是1，就意味着相应的权限开启，反之就是关闭</li>\n<li>0777八进制就是对操作系统中的所有用户都对当前的文件有读、写和执行的权限</li>\n<li>0666八进制就是所有用户对当前文件有读和写的权限，但没有执行的权限</li>\n<li>注意，只有在新建文件的时候，OpenFile函数的三个参数的第三个参数值才有效</li>\n<li>如果对已经存在的文件，使用OpenFile的时候，设置了这个参数，不会对目标文件产生任何影响</li>\n</ul>\n","prev":{"title":"【Go语言核心36讲】46. 访问网络服务","link":"2021/03/12/2021-03-12-02"},"next":{"title":"【Go语言核心36讲】42/43. bufio包中的数据类型","link":"2021/03/11/2021-03-11-01"},"plink":"https://terence.segofun.com/2021/03/12/2021-03-12-01/"}