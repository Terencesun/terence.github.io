{"title":"【go】Goroutine的GPM模型","date":"2020-10-07T01:22:52.000Z","date_formatted":{"ll":"Oct 7, 2020","L":"10/07/2020","MM-DD":"10-07"},"link":"2020/10/07/2020-10-07-01","comments":true,"tags":["golang","language"],"updated":"2022-10-17T01:08:12.552Z","content":"<h2 id=\"goroutine的gmp模型\">Goroutine的GMP模型<a title=\"#goroutine的gmp模型\" href=\"#goroutine的gmp模型\"></a></h2>\n<hr>\n<h3 id=\"1.-进程、线程和协程\">1. 进程、线程和协程<a title=\"#1.-进程、线程和协程\" href=\"#1.-进程、线程和协程\"></a></h3>\n<h4 id=\"1.1-进程\">1.1 进程<a title=\"#1.1-进程\" href=\"#1.1-进程\"></a></h4>\n<p>进程是系统资源分配的最小单位, 进程包括文本段text region、数据段data region和堆栈段stack region等。进程的创建和销毁都是系统资源级别的，因此是一种比较昂贵的操作，进程是抢占式调度其有三个状态:等待态、就绪态、运行态。进程之间是相互隔离的，它们各自拥有自己的系统资源, 更加安全但是也存在进程间通信不便的问题</p>\n<h4 id=\"1.2-线程\">1.2 线程<a title=\"#1.2-线程\" href=\"#1.2-线程\"></a></h4>\n<p>进程是线程的载体容器，多个线程除了共享进程的资源还拥有自己的一少部分独立的资源，因此相比进程而言更加轻量，进程内的多个线程间的通信比进程容易，但是也同样带来了同步和互斥的问题和线程安全问题，尽管如此多线程编程仍然是当前服务端编程的主流，线程也是CPU调度的最小单位，多线程运行时就存在线程切换问题</p>\n<h4 id=\"1.3-协程\">1.3 协程<a title=\"#1.3-协程\" href=\"#1.3-协程\"></a></h4>\n<p>协程在有的资料中称为微线程或者用户态轻量级线程，协程调度不需要内核参与而是完全由用户态程序来决定，因此协程对于系统而言是无感知的。协程由用户态控制就不存在抢占式调度那样强制的CPU控制权切换到其他进线程，多个协程进行协作式调度，协程自己主动把控制权转让出去之后，其他协程才能被执行到，这样就避免了系统切换开销提高了CPU的使用效率</p>\n<h4 id=\"1.4-总结\">1.4 总结<a title=\"#1.4-总结\" href=\"#1.4-总结\"></a></h4>\n<ul>\n<li>进程和线程都是由系统内核进行调度的，属于抢占式调度，由于内核资源有限，创建进程和线程开销较大</li>\n<li>协程由于是在用户层面调度，所以资源的使用取决于该协程的进程容器能获取到的资源，理论上，由于是自己控制，并且在进程的资源中可以共享部分资源，开销较小</li>\n<li>对于go来说，一个协程创建给的栈大小为几kb，所以当大量创建的时候，资源消耗较java等其他语言，都是较小的</li>\n<li>由于协程的特性(小巧快速)，常用于异步操作，比如IO这种操作，这就导致go的并发可以很大</li>\n</ul>\n<h3 id=\"2.-go和协程\">2. go和协程<a title=\"#2.-go和协程\" href=\"#2.-go和协程\"></a></h3>\n<p>由于go的协程特点，go的CSP并发模型能有很高的性能</p>\n<h4 id=\"2.1-协程的调度\">2.1 协程的调度<a title=\"#2.1-协程的调度\" href=\"#2.1-协程的调度\"></a></h4>\n<p>在用户层面创建协程后，用户需要调度这些协程，让协程可以充分利用CPU的时间，所以go自己有协程的调度器</p>\n<p>下面是goroutine的发展历史</p>\n<p><img src=\"/images/2020-10-07-01/goroutine_history.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"2.2-gpm模型\">2.2 GPM模型<a title=\"#2.2-gpm模型\" href=\"#2.2-gpm模型\"></a></h4>\n<h5 id=\"2.2.1-几个概念\">2.2.1 几个概念<a title=\"#2.2.1-几个概念\" href=\"#2.2.1-几个概念\"></a></h5>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>名称</th>\n<th>概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>逻辑处理器</td>\n<td>执行创建的goroutine，绑定一个线程</td>\n</tr>\n<tr>\n<td>调度器</td>\n<td>go运行时钟的，分配goroutine给不同的逻辑处理器</td>\n</tr>\n<tr>\n<td>全局运行队列</td>\n<td>所有刚创建的goroutine都会放在这里</td>\n</tr>\n<tr>\n<td>本地运行队列</td>\n<td>逻辑处理器的goroutine队列</td>\n</tr>\n</tbody>\n</table></div></div><h5 id=\"2.2.2-gpm模型\">2.2.2 GPM模型<a title=\"#2.2.2-gpm模型\" href=\"#2.2.2-gpm模型\"></a></h5>\n<ul>\n<li>\n<p>GPM模型的调度器是M:N类型的，多线程对应多个协程，多对多，这种调度器的复杂度较大</p>\n</li>\n<li>\n<p>GPM模型图</p>\n</li>\n</ul>\n<p><img src=\"/images/2020-10-07-01/GPM%E6%A8%A1%E5%9E%8B-1.png\" alt=\"GPM模型图1\" loading=\"lazy\"><br>\n<img src=\"/images/2020-10-07-01/GPM%E6%A8%A1%E5%9E%8B-2.png\" alt=\"GPM模型图2\" loading=\"lazy\"></p>\n<ul>\n<li>模型图中GPM的调度过程</li>\n</ul>\n<p><strong>a)</strong> 新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，最终等待被逻辑处理器P执行即可</p>\n<p><strong>b)</strong> 在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡</p>\n<ul>\n<li>goroutine在整个生存期内有不用的状态切换</li>\n</ul>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>状态</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_Gidle</td>\n<td>刚刚被分配并且还没有被初始化</td>\n</tr>\n<tr>\n<td>_Grunnable</td>\n<td>没有执行代码、没有栈的所有权、存储在运行队列中</td>\n</tr>\n<tr>\n<td>_Grunning</td>\n<td>可以执行代码、拥有栈的所有权，被赋予了内核线程M和处理器P</td>\n</tr>\n<tr>\n<td>_Gsyscall</td>\n<td>正在执行系统调用、拥有栈的所有权、没有执行用户代码，被赋予了内核线程M但不在运行队列上</td>\n</tr>\n<tr>\n<td>_Gwaiting</td>\n<td>由于运行时而被阻塞，没有执行用户代码并且不再运行队列上，但是可能存在于Channel的等待队列上</td>\n</tr>\n<tr>\n<td>_Gdead</td>\n<td>没有被使用，没有执行代码，可能有分配的栈</td>\n</tr>\n<tr>\n<td>_Gcopystack</td>\n<td>栈正在被拷贝、没有执行代码、不在运行队列上</td>\n</tr>\n</tbody>\n</table></div></div><ul>\n<li>不同状态的状态流程图<br>\n<img src=\"/images/2020-10-07-01/GPM%E6%A8%A1%E5%9E%8B-3.png\" alt=\"GPM模型状态流程\" loading=\"lazy\"></li>\n</ul>\n<h3 id=\"3.-参考\">3. 参考<a title=\"#3.-参考\" href=\"#3.-参考\"></a></h3>\n<p><a href=\"https://mp.weixin.qq.com/s/jnznPCiHwjd3756BYrLuPA\" target=\"_blank\">理解Go语言的Goroutine和协程</a></p>\n","prev":{"title":"【go】ioutil包详解","link":"2020/10/07/2020-10-07-02"},"next":{"title":"【go】go内置的json解析","link":"2020/09/30/2020-09-30-01"},"plink":"https://terence.segofun.com/2020/10/07/2020-10-07-01/","toc":[{"id":"goroutine的gmp模型","title":"Goroutine的GMP模型","index":"1","children":[{"id":"1.-进程、线程和协程","title":"1. 进程、线程和协程","index":"1.1"},{"id":"2.-go和协程","title":"2. go和协程","index":"1.2"},{"id":"3.-参考","title":"3. 参考","index":"1.3"}]}],"reading_time":"1350 words in 9 min"}