{"title":"【Go语言核心36讲】16/17. go语句及其执行规则","date":"2021-02-18T11:45:26.000Z","date_formatted":{"ll":"Feb 18, 2021","L":"02/18/2021","MM-DD":"02-18"},"link":"2021/02/18/2021-02-18-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-19T01:11:22.483Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>goroutine 代表着并发编程模型中的用户级线程</li>\n<li>进程，描述的就是程序的执行过程，是运行着的程序的代表</li>\n<li>一个进程其实就是某个程序运行时的一个产物</li>\n<li>线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）</li>\n<li>一个进程至少会包含一个线程。如果一个进程只包含了一个线程，那么它里面的所有代码都只会被串行地执行</li>\n<li>如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行</li>\n<li>主线程之外的其他线程都只能由代码显式地创建和销毁</li>\n<li>在 Go 程序当中，Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程(操作系统提供的线程)</li>\n<li>用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理</li>\n<li>如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳；如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现</li>\n<li>Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，还拥有强大的用于调度 goroutine、对接系统级线程的调度器</li>\n<li>调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）</li>\n<li>M 系统级线程，P 操作者，承载若干个G队列，并且使得G与M进行对接，这个时候G和M能形成多对多的关系，当遇到IO的时候，P把G和M分开，然后G独自等待IO的返回，当有返回的时候，G又被挂到M上进行处理</li>\n<li>一个 G 需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括 M）并安排运行。另外，当 M 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 M 已无用时，调度器又会负责把它及时地销毁掉<br>\n<img src=\"../images/store/4yyFFf.png\" alt=\"\"></li>\n<li>与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine</li>\n<li>一定要注意，go函数真正被执行的时间，总会与其所属的go语句被执行的时间不同。当程序执行到一条go语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine），它只有在找不到空闲 G 的情况下才会去创建一个新的 G；已存在的 goroutine 总是会被优先复用</li>\n<li>创建 G 的成本也是非常低的。创建一个 G 并不会像新建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成，在 Go 语言的运行时系统内部就可以完全做到了，更何况一个 G 仅相当于为需要并发执行代码片段服务的上下文环境而已</li>\n<li>在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数（或者说该函数中的那些代码），然后再把这个 G 追加到某个存放可运行的 G 的队列中</li>\n<li>这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的</li>\n<li>一旦主 goroutine 中的代码（也就是main函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行</li>\n<li>严谨地讲，Go 语言并不会去保证这些 goroutine 会以怎样的顺序运行。由于主 goroutine 会与我们手动启用的其他 goroutine 一起接受调度，又因为调度器很可能会在 goroutine 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会</li>\n<li>用什么手段可以对 goroutine 的启用数量加以限制？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime.GOMAXPROCS(maxProcs) &#x2F;&#x2F; 这个是用于控制P的数量，不是G的数量</span><br><span class=\"line\">buffered channel &#x2F;&#x2F; 可以限制G的数量</span><br><span class=\"line\">waitgroup &#x2F;&#x2F; 分组进行限制G的数量</span><br></pre></td></tr></table></figure>\n<ol start=\"23\">\n<li>怎样才能让主 goroutine 等待其他 goroutine？</li>\n</ol>\n<ul>\n<li>让主goroutine sleep一会</li>\n<li>通过channel进行通知</li>\n<li>waitgroup</li>\n</ul>\n<ol start=\"24\">\n<li>\n<p>struct{}{} 这个值 占用的空间为0字节，并且在整个go程序中只会有一份，会不断复用</p>\n</li>\n<li>\n<p>控制goroutine结束顺序本子就是主Goroutine作为控制中心，控制其他Goroutine</p>\n</li>\n</ol>\n","prev":{"title":"【Go语言核心36讲】18. if语句、for语句和switch语句","link":"2021/02/18/2021-02-18-02"},"next":{"title":"【Go语言核心36讲】15. 关于指针的有限操作","link":"2021/02/17/2021-02-17-14"},"plink":"https://terence.segofun.com/2021/02/18/2021-02-18-01/"}