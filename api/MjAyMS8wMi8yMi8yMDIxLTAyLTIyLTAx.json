{"title":"【Go语言核心36讲】32. context.Context类型","date":"2021-02-22T02:01:20.000Z","date_formatted":{"ll":"Feb 22, 2021","L":"02/22/2021","MM-DD":"02-22"},"link":"2021/02/22/2021-02-22-01","comments":true,"tags":["Go语言核心36讲","极客时间"],"updated":"2021-02-22T08:17:23.168Z","content":"<blockquote>\n<p>Hi, 如果你看到这篇文章，那么我是根据极客时间的郝林老师的Go语言核心36讲记录的笔记<br>\n如果对Go语言核心36讲感兴趣的，请支持原作者<br>\n地址：<a href=\"https://time.geekbang.org/column/intro/112\">https://time.geekbang.org/column/intro/112</a></p>\n</blockquote>\n<ol>\n<li>对于数量不一定的goroutine如何使用waitGroup来控制？</li>\n</ol>\n<ul>\n<li>分批进行，一批一批的wait</li>\n<li>换个方案用context</li>\n</ul>\n<ol start=\"2\">\n<li>一段代码描述</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; addNum 用于原子地增加一次numP所指的变量的值。</span><br><span class=\"line\">func addNum(numP *int32, id int, deferFunc func()) &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tdeferFunc()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tfor i :&#x3D; 0; ; i++ &#123;</span><br><span class=\"line\">\t\tcurrNum :&#x3D; atomic.LoadInt32(numP)</span><br><span class=\"line\">\t\tnewNum :&#x3D; currNum + 1</span><br><span class=\"line\">\t\tif id &#x3D;&#x3D; 4 &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;goroutine进入：%d\\n&quot;, id)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttime.Sleep(time.Millisecond * 2000)</span><br><span class=\"line\">\t\tif atomic.CompareAndSwapInt32(numP, currNum, newNum) &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;数字: %d\\t\\tgoroutine编号: %d\\t\\t执行序号：%d\\n&quot;, newNum, id, i+1)</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tif id &#x3D;&#x3D; 4 &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(&quot;goroutine比较失败：%d\\n&quot;, id)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;fmt.Printf(&quot;The CAS operation failed. [%d-%d]\\n&quot;, id, i)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func coordinateWithContext() &#123;</span><br><span class=\"line\"> total :&#x3D; 12</span><br><span class=\"line\"> var num int32</span><br><span class=\"line\"> fmt.Printf(&quot;数字: %d\\t\\t[with context.Context]\\n&quot;, num)</span><br><span class=\"line\"> cxt, cancelFunc :&#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\"> for i :&#x3D; 1; i &lt;&#x3D; total; i++ &#123;</span><br><span class=\"line\">  go addNum(&amp;num, i, func() &#123;</span><br><span class=\"line\">   if atomic.LoadInt32(&amp;num) &#x3D;&#x3D; int32(total) &#123;</span><br><span class=\"line\">    cancelFunc()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> &lt;-cxt.Done()</span><br><span class=\"line\"> fmt.Println(&quot;End.&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>代码中，原子操作CAS，这个时候12个goroutine都会在第一次的时候执行到CompareAndSwapInt32这里</li>\n<li>由于原子操作，只会有一个goroutine修改成功，那么其他的goroutine就会失败，进到else里面，然后进到下一次循环，如此往复</li>\n<li>每一次修改成功，都会执行到defer上面，由于defer上面还有一个判断atomic.LoadInt32(&amp;num) == int32(total)，并且这个判断是原子性的，一个goroutine只能隔离去拿，所以只有一个goroutine能判断为true</li>\n<li>这个时候就会执行cancelFunc()，注意这个cancelFunc()只会执行一次，因为只有一个goroutine判断成功</li>\n<li>这个时候cxt.Done()就会取值，取消阻塞了，然后程序就执行完毕了</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>context类型是个接口类型，实现context的所有类型都是基于某个数据类型的指针类型，也就是说context的传播并不会影响其本身的值</p>\n</li>\n<li>\n<p>在一个程序中的context值共同构成了一颗代表上下文全貌的树形结构</p>\n</li>\n<li>\n<p>context树根（上下文根节点）是一个已经在context包中预定义好的context值，全局唯一。通过调用context.Background函数，就可以获取到它</p>\n</li>\n<li>\n<p>上下文根节点是最基本的节点，不提供任何额外的功能，不可以被撤销cancel，也不能携带任何数据</p>\n</li>\n<li>\n<p>context包里面有四种繁衍context值的函数：WithCancel、WithDeadline、WithTimeout和WithValue，注意这里是用来繁衍用的，所以需要基于树根context，然后每当我们繁衍的时候，就又需要父级context</p>\n</li>\n<li>\n<p>四种繁衍函数的说明：</p>\n</li>\n</ol>\n<ul>\n<li>WithCancel -&gt; 用于产生一个可撤销的parent的子值，获得一个衍生自上下文根节点的Context值，和一个用于触发撤销信号的函数</li>\n<li>WithDeadline -&gt; 可以被用来产生一个会定时撤销的parent的子值</li>\n<li>WithTimeout -&gt; 可以被用来产生一个会定时撤销的parent的子值</li>\n<li>WithValue -&gt; 产生一个会携带额外数据的parent的子值，注意这个产生的context是不可以撤销的，如果父级或子集撤销，会绕过它急需要撤销其他</li>\n</ul>\n<ol start=\"9\">\n<li>\n<p>所有context类型都有一个Done方法，这个方法会返回一个struct{}的接受channel，用于感知撤销动作，一旦有context发出撤销信号，那么其父级和父父级…往上的Done的通道都会感知到</p>\n</li>\n<li>\n<p>当有context撤销的时候，我们有时需要知道撤销的原因，可以使用context类型的Err方法</p>\n</li>\n<li>\n<p>代码可以在感知到撤销信号之后，进行任意的操作，Context值对此并没有任何的约束<br>\n<img src=\"../images/store/MIK-9ltdM9.png\" alt=\"\"></p>\n</li>\n<li>\n<p>context是通过withValue创建的，都是通过父值和子值表达关系的</p>\n</li>\n<li>\n<p>Context类型的实际值大体上分为三种</p>\n</li>\n</ol>\n<ul>\n<li>根context值</li>\n<li>可撤销的context值</li>\n<li>含数据的context值</li>\n</ul>\n<ol start=\"14\">\n<li>含数据的Context值不能被撤销，而可撤销的Context值又无法携带数据</li>\n</ol>\n","next":{"title":"【Go语言核心36讲】31. sync.WaitGroup和sync.Once","link":"2021/02/21/2021-02-21-02"},"plink":"https://terence.segofun.com/2021/02/22/2021-02-22-01/"}